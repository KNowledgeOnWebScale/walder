import 'isomorphic-fetch';
import { IDocumentLoader } from "./IDocumentLoader";
import { IJsonLdContextNormalized, JsonLdContext } from "./JsonLdContext";
/**
 * Parses JSON-LD contexts.
 */
export declare class ContextParser implements IDocumentLoader {
    static readonly IRI_REGEX: RegExp;
    private static readonly EXPAND_KEYS_BLACKLIST;
    private static readonly ALIAS_KEYS_BLACKLIST;
    private static readonly CONTAINERS;
    private readonly documentLoader;
    private readonly documentCache;
    private readonly validate;
    private readonly expandContentTypeToBase;
    constructor(options?: IContextParserOptions);
    /**
     * Get the prefix from the given term.
     * @see https://json-ld.org/spec/latest/json-ld/#compact-iris
     * @param {string} term A term that is an URL or a prefixed URL.
     * @param {IJsonLdContextNormalized} context A context.
     * @return {string} The prefix or null.
     */
    static getPrefix(term: string, context: IJsonLdContextNormalized): string;
    /**
     * From a given context entry value, get the string value, or the @id field.
     * @param contextValue A value for a term in a context.
     * @return {string} The id value, or null.
     */
    static getContextValueId(contextValue: any): string;
    /**
     * Expand the term or prefix of the given term if it has one,
     * otherwise return the term as-is.
     *
     * Iff in vocab-mode, then other references to other terms in the context can be used,
     * such as to `myTerm`:
     * ```
     * {
     *   "myTerm": "http://example.org/myLongTerm"
     * }
     * ```
     *
     * @param {string} term A term that is an URL or a prefixed URL.
     * @param {IJsonLdContextNormalized} context A context.
     * @param {boolean} vocab If the term is a predicate or type and should be expanded based on @vocab,
     *                        otherwise it is considered a regular term that is expanded based on @base.
     * @return {string} The expanded term, the term as-is, or null if it was explicitly disabled in the context.
     */
    static expandTerm(term: string, context: IJsonLdContextNormalized, vocab?: boolean): string;
    /**
     * Compact the given term using @base, @vocab, an aliased term, or a prefixed term.
     * @param {string} iri An IRI to compact.
     * @param {IJsonLdContextNormalized} context The context to compact with.
     * @param {boolean} vocab If the term is a predicate or type and should be compacted based on @vocab,
     *                        otherwise it is considered a regular term that is compacted based on @base.
     * @return {string} The compacted term or the IRI as-is.
     */
    static compactIri(iri: string, context: IJsonLdContextNormalized, vocab?: boolean): string;
    /**
     * Check if the given context value can be a prefix value.
     * @param value A context value.
     * @return {boolean} If it can be a prefix value.
     */
    static isPrefixValue(value: any): boolean;
    /**
     * Check if the given IRI is valid.
     * @param {string} iri A potential IRI.
     * @return {boolean} If the given IRI is valid.
     */
    static isValidIri(iri: string): boolean;
    /**
     * Add an @id term for all @reverse terms.
     * @param {IJsonLdContextNormalized} context A context.
     * @return {IJsonLdContextNormalized} The mutated input context.
     */
    static idifyReverseTerms(context: IJsonLdContextNormalized): IJsonLdContextNormalized;
    /**
     * Expand all prefixed terms in the given context.
     * @param {IJsonLdContextNormalized} context A context.
     * @param {boolean} expandContentTypeToBase If @type inside the context may be expanded
     *                                          via @base if @vocab is set to null.
     * @return {IJsonLdContextNormalized} The mutated input context.
     */
    static expandPrefixedTerms(context: IJsonLdContextNormalized, expandContentTypeToBase: boolean): IJsonLdContextNormalized;
    /**
     * Validate the entries of the given context.
     * @param {IJsonLdContextNormalized} context A context.
     */
    static validate(context: IJsonLdContextNormalized): void;
    /**
     * Parse a JSON-LD context in any form.
     * @param {JsonLdContext} context A context, URL to a context, or an array of contexts/URLs.
     * @param {IParseOptions} options Optional parsing options.
     * @return {Promise<IJsonLdContextNormalized>} A promise resolving to the context.
     */
    parse(context: JsonLdContext, { baseIri, parentContext, external }?: IParseOptions): Promise<IJsonLdContextNormalized>;
    load(url: string): Promise<IJsonLdContextNormalized>;
}
export interface IContextParserOptions {
    /**
     * An optional loader that should be used for fetching external JSON-LD contexts.
     */
    documentLoader?: IDocumentLoader;
    /**
     * By default, JSON-LD contexts will be validated.
     * This can be disabled by setting this option to true.
     * This will achieve slightly better performance for large contexts,
     * and may be useful if contexts are known to be valid.
     */
    skipValidation?: boolean;
    /**
     * If @type inside the context may be expanded via @base is @vocab is set to null.
     */
    expandContentTypeToBase?: boolean;
}
export interface IParseOptions {
    /**
     * An optional fallback base IRI to set.
     */
    baseIri?: string;
    /**
     * The parent context.
     */
    parentContext?: IJsonLdContextNormalized;
    /**
     * If the parsing context is an external context.
     */
    external?: boolean;
}
