import * as RDF from "rdf-js";
import { IActiveTag } from "./IActiveTag";
import { RdfaProfile } from "./RdfaProfile";
/**
 * A collection of utility functions.
 */
export declare class Util {
    static readonly RDF = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
    static readonly XSD = "http://www.w3.org/2001/XMLSchema#";
    static readonly RDFA = "http://www.w3.org/ns/rdfa#";
    private static readonly PREFIX_REGEX;
    private static readonly TIME_REGEXES;
    private static readonly IRI_REGEX;
    readonly dataFactory: RDF.DataFactory;
    baseIRI: RDF.NamedNode;
    blankNodeFactory: () => RDF.BlankNode;
    private readonly baseIRIDocument;
    constructor(dataFactory: RDF.DataFactory, baseIRI: string);
    /**
     * Retrieve the prefixes of the current tag's attributes.
     * @param {{[p: string]: string}} attributes A tag's attributes.
     * @param {{[p: string]: string}} parentPrefixes The prefixes from the parent tag.
     * @param {boolean} xmlnsPrefixMappings If prefixes should be extracted from xmlnsPrefixMappings.
     * @return {{[p: string]: string}} The new prefixes.
     */
    static parsePrefixes(attributes: {
        [s: string]: string;
    }, parentPrefixes: {
        [prefix: string]: string;
    }, xmlnsPrefixMappings: boolean): {
        [prefix: string]: string;
    };
    /**
     * Expand the given term value based on the given prefixes.
     * @param {string} term A term value.
     * @param {{[p: string]: string}[]} prefixes The available prefixes.
     * @return {string} An expanded URL, or the term as-is.
     */
    static expandPrefixedTerm(term: string, activeTag: IActiveTag): string;
    /**
     * Check if the given IRI is valid.
     * @param {string} iri A potential IRI.
     * @return {boolean} If the given IRI is valid.
     */
    static isValidIri(iri: string): boolean;
    /**
     * Determine the RDFa profile from the given content type.
     * Defaults to the default RDFa profile (all features enabled) for unknown content types.
     * @param {string} contentType A content type.
     * @returns {RdfaProfile} An RDFa profile.
     */
    static contentTypeToProfile(contentType: string): RdfaProfile;
    /**
     * Get the base IRI.
     * @param {string} baseIriValue A base IRI value.
     * @return A base IRI named node.
     */
    getBaseIRI(baseIriValue: string): RDF.NamedNode;
    /**
     * If the term is a boolean, return the baseIRI, otherwise return the term as-is.
     * @param {Term | boolean} term A term or boolean, where the boolean indicates the baseIRI.
     * @param {IActiveTag} activeTag An active tag.
     * @returns {Term} A term.
     */
    getResourceOrBaseIri(term: RDF.Term | boolean, activeTag: IActiveTag): RDF.Term;
    /**
     * Get the active base IRI as an RDF term.
     * @param {IActiveTag} activeTag The active tag.
     * @return {NamedNode} The base IRI term.
     */
    getBaseIriTerm(activeTag: IActiveTag): RDF.NamedNode;
    /**
     * Create vocab terms for the given terms attribute.
     * @param {string} terms An attribute value.
     * @param {IActiveTag} activeTag The current active tag.
     * @param {boolean} allowTerms If terms are allowed (strings without ':')
     * @param {boolean} allowBlankNode If blank nodes are allowed.
     * @return {Term[]} The IRI terms.
     */
    createVocabIris(terms: string, activeTag: IActiveTag, allowTerms: boolean, allowBlankNode: boolean): RDF.Term[];
    /**
     * Create a new literal node.
     * @param {string} literal The literal value.
     * @param {IActiveTag} activeTag The current active tag.
     * @return {Literal} A new literal node.
     */
    createLiteral(literal: string, activeTag: IActiveTag): RDF.Literal;
    /**
     * Create a blank node.
     * @returns {BlankNode} A new blank node.
     */
    createBlankNode(): RDF.BlankNode;
    /**
     * Create a named node for the given term.
     * This will take care of prefix detection.
     * @param {string} term A term string (CURIE or IRI, aka safe-CURIE in RDFa spec).
     * @param {IActiveTag} activeTag The current active tag.
     * @param {boolean} vocab If creating an IRI in vocab-mode (based on vocab IRI),
     *                        or in base-mode (based on base IRI).
     * @param {boolean} allowSafeCurie If safe CURIEs are allowed
     *                                 (invalid CURIEs between square brackets will return null)
     *                                 Otherwise, only IRIs are allowed.
     * @param {boolean} allowBlankNode If blank nodes are allowed. Otherwise null will be returned.
     * @return {Term} An RDF term or null.
     */
    createIri(term: string, activeTag: IActiveTag, vocab: boolean, allowSafeCurie: boolean, allowBlankNode: boolean): RDF.Term;
}
