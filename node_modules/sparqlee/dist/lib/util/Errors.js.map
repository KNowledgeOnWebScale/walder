{"version":3,"file":"Errors.js","sourceRoot":"","sources":["../../../lib/util/Errors.ts"],"names":[],"mappings":"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","sourcesContent":["import * as RDF from 'rdf-js';\nimport { Algebra } from 'sparqlalgebrajs';\n\nimport * as E from '../expressions';\nimport * as C from './Consts';\n\nimport { Bindings } from '../Types';\n\n/**\n * This class of error will be thrown when an expression errors.\n * Various reasons this could happen are:\n *   - invalid types for the given operator\n *   - unbound variables\n *   - invalid lexical forms\n *   - ...\n *\n * The distinction is made so that one can catch this specific type\n * and handle it accordingly to the SPARQL spec (relevant for e.g. FILTER, EXTEND),\n * while others (programming errors) can be re-thrown.\n *\n * @see isExpressionError\n */\nexport class ExpressionError extends Error { }\n\n/**\n * Checks whether a given error is an {@link ExpressionError}.\n * Also useful for mocking in tests for covering all branches.\n *\n * @see ExpressionError\n */\nexport function isExpressionError(error: Error): boolean {\n  return error instanceof ExpressionError;\n}\n\n/**\n * A literal has an invalid lexical form for the datatype it is accompanied by.\n * This error is only thrown when the term is as function argument that requires\n * a valid lexical form.\n */\nexport class InvalidLexicalForm extends ExpressionError {\n  constructor(public arg: RDF.Term) {\n    super(`Invalid lexical form '${pp(arg)}'`);\n  }\n}\n\n/**\n * A variable in the expression was not bound.\n */\nexport class UnboundVariableError extends ExpressionError {\n  constructor(public variable: string, public bindings: Bindings) {\n    super(`Unbound variable '${pp(variable)}'`);\n  }\n}\n\n/**\n * An invalid term was being coerced to an Effective Boolean Value.\n *\n * See the {@link https://www.w3.org/TR/sparql11-query/#ebv | SPARQL docs}\n * on EBVs.\n */\nexport class EBVCoercionError extends ExpressionError {\n  constructor(public arg: E.Term) {\n    super(`Cannot coerce term to EBV '${pp(arg)}'`);\n  }\n}\n\n/**\n * An equality test was done on literals with unsupported datatypes.\n *\n * See {@link https://www.w3.org/TR/sparql11-query/#func-RDFterm-equal | term equality spec}.\n */\nexport class RDFEqualTypeError extends ExpressionError {\n  constructor(public args: E.Expression[]) {\n    super('Equality test for literals with unsupported datatypes');\n  }\n}\n\n/**\n * All the expressions in a COALESCE call threw errors.\n */\nexport class CoalesceError extends ExpressionError {\n  constructor(public errors: Error[]) {\n    super('All COALESCE arguments threw errors');\n  }\n}\n\n/**\n * No arguments to an IN call where equal, and at least one threw an error.\n */\nexport class InError extends ExpressionError {\n  constructor(public errors: Array<Error | false>) {\n    super(\n      'Some argument to IN errorred and none where equal. ' +\n      errors.map((err) => `(${err.toString()}) `).join('and '));\n  }\n}\n\n/**\n * Literals were passed to an operator that doesn't support their datatypes.\n */\nexport class InvalidArgumentTypes extends ExpressionError {\n  constructor(public args: E.Expression[], public op: C.Operator | C.NamedOperator) {\n    super(`Argument types not valid for operator: '${pp(op)}' with '${pp(args)}`);\n  }\n}\n\n/**\n * An invalid typecast happened.\n */\nexport class CastError<T> extends ExpressionError {\n  constructor(public arg: T, cast: C.TypeURL) {\n    super(`Invalid cast: '${pp(arg)}' to '${pp(cast)}'`);\n  }\n}\n\nexport class InvalidTimezoneCall extends ExpressionError {\n  constructor(public dateString: string) {\n    super(`TIMEZONE call on ${dateString} which has no timezone`);\n  }\n}\n\nexport class IncompatibleLanguageOperation extends ExpressionError {\n  constructor(public arg1: E.LangStringLiteral, public arg2: E.LangStringLiteral) {\n    super(`Operation on incompatible language literals '${pp(arg1)}' and '${pp(arg2)}'`);\n  }\n}\n\nexport class EmptyAggregateError extends ExpressionError {\n  constructor() {\n    super('Empty aggregate expression');\n  }\n}\n\n// Non Expression Errors ------------------------------------------------------\n\n/**\n * An error that arises when we detect a 'should-be-impossible' state.\n * Given that this error is thrown, it clearly wasn't impossible, and some\n * mistake has been made.\n */\nexport class UnexpectedError<T> extends Error {\n  constructor(message: string, public payload?: T) {\n    super(`Programmer Error '${message}'`);\n  }\n}\n\n/**\n * An Error that signals a feature or function is yet unimplemented.\n */\nexport class UnimplementedError extends Error {\n  constructor(feature: string) {\n    super(`Unimplemented feature '${feature}!'`);\n  }\n}\n\nexport class InvalidArity extends Error {\n  constructor(public args: E.Expression[], public op: C.Operator) {\n    super(`The number of args does not match the arity of the operator '${pp(op)}'.`);\n  }\n}\n\nexport class InvalidExpression<T> extends Error {\n  constructor(expr: T) {\n    super(`Invalid SPARQL Expression '${pp(expr)}'`);\n  }\n}\n\nexport class InvalidExpressionType<T> extends Error {\n  constructor(public expr: T) {\n    super(`Invalid expression type for SPARQL Expression '${pp(expr)}'`);\n  }\n}\n\nexport class InvalidTermType extends Error {\n  constructor(public term: Algebra.TermExpression) {\n    super(`Invalid term type for term '${pp(term)}'`);\n  }\n}\n\nexport class UnknownOperator extends Error {\n  constructor(name: string) {\n    super(`Unknown operator: '${pp(name)}`);\n  }\n}\n\nexport class UnknownNamedOperator extends Error {\n  constructor(name: string) {\n    super(`Unknown named operator: '${pp(name)}'`);\n  }\n}\n\nexport class NoAggregator extends Error {\n  constructor(name?: string) {\n    super(`Aggregate expression ${pp(name)} found, but no aggregate hook provided.`);\n  }\n}\n\nexport class NoExistenceHook extends Error {\n  constructor() {\n    super('EXISTS found, but no existence hook provided.');\n  }\n}\n\nfunction pp<T>(o: T) {\n  return JSON.stringify(o);\n}\n"]}