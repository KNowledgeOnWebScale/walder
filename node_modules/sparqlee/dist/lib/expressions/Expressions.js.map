{"version":3,"file":"Expressions.js","sourceRoot":"","sources":["../../../lib/expressions/Expressions.ts"],"names":[],"mappings":";;AAKA,IAAY,cAQX;AARD,WAAY,cAAc;IACxB,yCAAuB,CAAA;IACvB,yCAAuB,CAAA;IACvB,iCAAe,CAAA;IACf,uCAAqB,CAAA;IACrB,qDAAmC,CAAA;IACnC,+BAAa,CAAA;IACb,uCAAqB,CAAA;AACvB,CAAC,EARW,cAAc,GAAd,sBAAc,KAAd,sBAAc,QAQzB","sourcesContent":["import * as RDF from 'rdf-js';\nimport { Algebra } from 'sparqlalgebrajs';\n\nimport { Bindings } from '../Types';\n\nexport enum ExpressionType {\n  Aggregate = 'aggregate',\n  Existence = 'existence',\n  Named = 'named',\n  Operator = 'operator',\n  SpecialOperator = 'specialOperator',\n  Term = 'term',\n  Variable = 'variable',\n}\n\nexport type Expression =\n  AggregateExpression |\n  ExistenceExpression |\n  NamedExpression |\n  OperatorExpression |\n  SpecialOperatorExpression |\n  TermExpression |\n  VariableExpression;\n\nexport interface ExpressionProps {\n  expressionType: ExpressionType;\n}\n\nexport type AggregateExpression = ExpressionProps & {\n  expressionType: ExpressionType.Aggregate;\n  name: string;\n  expression: Algebra.AggregateExpression;\n};\n\nexport type ExistenceExpression = ExpressionProps & {\n  expressionType: ExpressionType.Existence;\n  expression: Algebra.ExistenceExpression;\n};\n\nexport type NamedExpression = ExpressionProps & {\n  expressionType: ExpressionType.Named;\n  name: RDF.NamedNode;\n  apply: SimpleApplication;\n  args: Expression[];\n};\n\n// export type Application = SimpleApplication | SpecialApplication;\nexport type SimpleApplication = (args: TermExpression[]) => TermExpression;\n\nexport type OperatorExpression = ExpressionProps & {\n  expressionType: ExpressionType.Operator;\n  args: Expression[];\n  apply: SimpleApplication;\n};\n\nexport type SpecialApplication<Term, BNode> = (context: EvalContext<Term, BNode>) => Term;\n\nexport type SpecialApplicationAsync = SpecialApplication<Promise<TermExpression>, Promise<RDF.BlankNode>>;\nexport type EvalContextAsync = EvalContext<Promise<TermExpression>, Promise<RDF.BlankNode>>;\n\nexport type SpecialApplicationSync = SpecialApplication<TermExpression, RDF.BlankNode>;\nexport type EvalContextSync = EvalContext<TermExpression, RDF.BlankNode>;\n\nexport type EvalContext<Term, BNode> = {\n  args: Expression[],\n  mapping: Bindings,\n  context: {\n    now: Date,\n    baseIRI?: string,\n    bnode(input?: string): BNode,\n  },\n  evaluate(expr: Expression, mapping: Bindings): Term,\n};\n\nexport type SpecialOperatorExpression = ExpressionProps & {\n  expressionType: ExpressionType.SpecialOperator,\n  args: Expression[],\n  applyAsync: SpecialApplicationAsync,\n  applySync: SpecialApplicationSync,\n};\n\n// TODO: Create alias Term = TermExpression\nexport type TermType = 'namedNode' | 'literal' | 'blankNode';\nexport type TermExpression = ExpressionProps & {\n  expressionType: ExpressionType.Term;\n  termType: TermType;\n  str(): string;\n  coerceEBV(): boolean;\n  toRDF(): RDF.Term;\n};\n\nexport type VariableExpression = ExpressionProps & {\n  expressionType: ExpressionType.Variable;\n  name: string;\n};\n"]}