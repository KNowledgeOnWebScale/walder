{"version":3,"file":"Transformation.js","sourceRoot":"","sources":["../../lib/Transformation.ts"],"names":[],"mappings":"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","sourcesContent":["import * as RDF from 'rdf-js';\nimport * as RDFString from 'rdf-string';\nimport { Algebra as Alg } from 'sparqlalgebrajs';\n\nimport * as E from './expressions';\nimport * as C from './util/Consts';\nimport * as Err from './util/Errors';\nimport * as P from './util/Parsing';\n\nimport {\n  namedFunctions,\n  regularFunctions,\n  specialFunctions,\n} from './functions';\nimport { TypeURL as DT } from './util/Consts';\n\nexport function transformAlgebra(expr: Alg.Expression): E.Expression {\n  if (!expr) { throw new Err.InvalidExpression(expr); }\n\n  const types = Alg.expressionTypes;\n\n  switch (expr.expressionType) {\n    case types.TERM:\n      return transformTerm(expr as Alg.TermExpression);\n    case types.OPERATOR:\n      return transformOperator(expr as Alg.OperatorExpression);\n    case types.NAMED:\n      return transformNamed(expr as Alg.NamedExpression);\n    case types.EXISTENCE:\n      return transformExistence(expr as Alg.ExistenceExpression);\n    case types.AGGREGATE:\n      return transformAggregate(expr as Alg.AggregateExpression);\n    default: throw new Err.InvalidExpressionType(expr);\n  }\n}\n\n/**\n * Transforms an RDF term to the internal representation of a term,\n * assuming it is not a variable, which would be an expression (internally).\n *\n * @param term RDF term to transform into internal representation of a term\n */\nexport function transformRDFTermUnsafe(term: RDF.Term): E.Term {\n  return transformTerm({\n    term,\n    type: 'expression',\n    expressionType: 'term',\n  }) as E.Term;\n}\n\nfunction transformTerm(term: Alg.TermExpression): E.Expression {\n  if (!term.term) { throw new Err.InvalidExpression(term); }\n\n  switch (term.term.termType) {\n    case 'Variable': return new E.Variable(RDFString.termToString(term.term));\n    case 'Literal': return transformLiteral(term.term as RDF.Literal);\n    case 'NamedNode': return new E.NamedNode(term.term.value);\n    case 'BlankNode': return new E.BlankNode(term.term.value);\n    default: throw new Err.InvalidTermType(term);\n  }\n}\n\n// TODO: Maybe do this with a map?\n// tslint:disable-next-line:no-any\nexport function transformLiteral(lit: RDF.Literal): E.Literal<any> {\n\n  if (!lit.datatype) {\n    return (lit.language)\n      ? new E.LangStringLiteral(lit.value, lit.language)\n      : new E.StringLiteral(lit.value);\n  }\n\n  switch (lit.datatype.value) {\n    case null:\n    case undefined:\n    case '': {\n      return (lit.language)\n        ? new E.LangStringLiteral(lit.value, lit.language)\n        : new E.StringLiteral(lit.value);\n    }\n\n    case DT.XSD_STRING:\n      return new E.StringLiteral(lit.value);\n    case DT.RDF_LANG_STRING:\n      return new E.LangStringLiteral(lit.value, lit.language);\n\n    case DT.XSD_DATE_TIME:\n    case DT.XSD_DATE: {\n      const val: Date = new Date(lit.value);\n      if (isNaN(val.getTime())) {\n        return new E.NonLexicalLiteral(undefined, lit.datatype, lit.value);\n      }\n      return new E.DateTimeLiteral(new Date(lit.value), lit.value);\n    }\n\n    case DT.XSD_BOOLEAN: {\n      if (lit.value !== 'true' && lit.value !== 'false') {\n        return new E.NonLexicalLiteral(undefined, lit.datatype, lit.value);\n      }\n      return new E.BooleanLiteral(lit.value === 'true', lit.value);\n    }\n\n    case DT.XSD_INTEGER:\n    case DT.XSD_DECIMAL:\n\n    case DT.XSD_NEGATIVE_INTEGER:\n    case DT.XSD_NON_NEGATIVE_INTEGER:\n    case DT.XSD_NON_POSITIVE_INTEGER:\n    case DT.XSD_POSITIVE_INTEGER:\n    case DT.XSD_LONG:\n    case DT.XSD_INT:\n    case DT.XSD_SHORT:\n    case DT.XSD_BYTE:\n    case DT.XSD_UNSIGNED_LONG:\n    case DT.XSD_UNSIGNED_INT:\n    case DT.XSD_UNSIGNED_SHORT:\n    case DT.XSD_UNSIGNED_BYTE:\n    case DT.XSD_INT: {\n      const val: number = P.parseXSDDecimal(lit.value);\n      if (val === undefined) {\n        return new E.NonLexicalLiteral(undefined, lit.datatype, lit.value);\n      }\n      return new E.NumericLiteral(val, lit.datatype, lit.value);\n    }\n    case DT.XSD_FLOAT:\n    case DT.XSD_DOUBLE: {\n      const val: number = P.parseXSDFloat(lit.value);\n      if (val === undefined) {\n        return new E.NonLexicalLiteral(undefined, lit.datatype, lit.value);\n      }\n      return new E.NumericLiteral(val, lit.datatype, lit.value);\n    }\n    default: return new E.Literal<string>(lit.value, lit.datatype, lit.value);\n  }\n}\n\nfunction transformOperator(expr: Alg.OperatorExpression)\n  : E.OperatorExpression | E.SpecialOperatorExpression {\n  if (C.SpecialOperators.contains(expr.operator)) {\n    const op = expr.operator as C.SpecialOperator;\n    const args = expr.args.map((a) => transformAlgebra(a));\n    const func = specialFunctions.get(op);\n    if (!func.checkArity(args)) {\n      throw new Err.InvalidArity(args, op);\n    }\n    return new E.SpecialOperator(args, func.applyAsync, func.applySync);\n  } else {\n    if (!C.Operators.contains(expr.operator)) {\n      throw new Err.UnknownOperator(expr.operator);\n    }\n    const op = expr.operator as C.RegularOperator;\n    const args = expr.args.map((a) => transformAlgebra(a));\n    const func = regularFunctions.get(op);\n    if (!hasCorrectArity(args, func.arity)) { throw new Err.InvalidArity(args, op); }\n    return new E.Operator(args, func.apply);\n  }\n}\n\n// TODO: Support passing functions to override default behaviour;\nexport function transformNamed(expr: Alg.NamedExpression): E.NamedExpression {\n  const funcName = expr.name.value;\n  if (!C.NamedOperators.contains(funcName as C.NamedOperator)) {\n    throw new Err.UnknownNamedOperator(expr.name.value);\n  }\n\n  // tslint:disable-next-line:no-any\n  const op = expr.name.value as any as C.NamedOperator;\n  const args = expr.args.map((a) => transformAlgebra(a));\n  const func = namedFunctions.get(op);\n  return new E.Named(expr.name, args, func.apply);\n}\n\nfunction hasCorrectArity(args: E.Expression[], arity: number | number[]): boolean {\n  // Infinity is used to represent var-args, so it's always correct.\n  if (arity === Infinity) { return true; }\n\n  // If the function has overloaded arity, the actual arity needs to be present.\n  if (Array.isArray(arity)) {\n    return arity.indexOf(args.length) >= 0;\n  }\n\n  return args.length === arity;\n}\n\nexport function transformAggregate(expr: Alg.AggregateExpression) {\n  const name = expr.aggregator;\n  return new E.Aggregate(name, expr);\n}\n\nexport function transformExistence(expr: Alg.ExistenceExpression) {\n  return new E.Existence(expr);\n}\n"]}