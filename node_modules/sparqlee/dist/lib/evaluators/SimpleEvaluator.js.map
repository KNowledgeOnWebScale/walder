{"version":3,"file":"SimpleEvaluator.js","sourceRoot":"","sources":["../../../lib/evaluators/SimpleEvaluator.ts"],"names":[],"mappings":"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","sourcesContent":["import * as RDF from 'rdf-js';\nimport { Algebra as Alg } from 'sparqlalgebrajs';\n\nimport * as E from '../expressions/Expressions';\nimport * as Err from '../util/Errors';\n\nimport { transformAlgebra, transformTerm } from '../Transformation';\nimport { Bindings } from '../Types';\n\ntype Expression = E.Expression;\ntype Term = E.TermExpression;\ntype Variable = E.VariableExpression;\ntype Existence = E.ExistenceExpression;\ntype Operator = E.OperatorExpression;\ntype SpecialOperator = E.SpecialOperatorExpression;\ntype Named = E.NamedExpression;\ntype Aggregate = E.AggregateExpression;\n\n/**\n * Evaluator that does not support EXISTS, AGGREGATES or custom Named operators.\n * Evaluates everything sync.\n */\nexport class SimpleEvaluator {\n  private expr: Expression;\n\n  constructor(public algExpr: Alg.Expression) {\n    this.expr = transformAlgebra(algExpr);\n  }\n\n  evaluate(mapping: Bindings): RDF.Term {\n    const result = this.evalRecursive(this.expr, mapping);\n    return log(result).toRDF();\n  }\n\n  evaluateAsEBV(mapping: Bindings): boolean {\n    const result = this.evalRecursive(this.expr, mapping);\n    return log(result).coerceEBV();\n  }\n\n  evaluateAsInternal(mapping: Bindings): Term {\n    return this.evalRecursive(this.expr, mapping);\n  }\n\n  // tslint:disable-next-line:member-ordering\n  private readonly evaluators: {\n    [key: string]: (expr: Expression, mapping: Bindings) => Term;\n  } = {\n      [E.ExpressionType.Term]: this.evalTerm,\n      [E.ExpressionType.Variable]: this.evalVariable,\n      [E.ExpressionType.Operator]: this.evalOperator,\n      [E.ExpressionType.SpecialOperator]: this.evalSpecialOperator,\n      [E.ExpressionType.Named]: this.evalNamed,\n      [E.ExpressionType.Existence]: this.evalExistence,\n      [E.ExpressionType.Aggregate]: this.evalAggregate,\n    };\n\n  private evalRecursive(expr: Expression, mapping: Bindings): Term {\n    const evaluator = this.evaluators[expr.expressionType];\n    if (!evaluator) { throw new Err.InvalidExpressionType(expr); }\n    return evaluator.bind(this)(expr, mapping);\n  }\n\n  private evalTerm(expr: Term, mapping: Bindings): Term {\n    return expr;\n  }\n\n  private evalVariable(expr: Variable, mapping: Bindings): Term {\n    const term = mapping.get(expr.name);\n\n    if (!term) { throw new Err.UnboundVariableError(expr.name, mapping); }\n\n    return transformTerm({\n      term,\n      type: 'expression',\n      expressionType: 'term',\n    }) as Term;\n  }\n\n  private evalOperator(expr: Operator, mapping: Bindings): Term {\n    const args = expr.args.map((arg) => this.evalRecursive(arg, mapping));\n    return expr.apply(args);\n  }\n\n  private evalSpecialOperator(expr: SpecialOperator, mapping: Bindings): Term {\n    const evaluate = this.evalRecursive.bind(this);\n    const context = { args: expr.args, mapping, evaluate };\n    return expr.applySync(context);\n  }\n\n  private evalNamed(expr: Named, mapping: Bindings): Term {\n    const args = expr.args.map((arg) => this.evalRecursive(arg, mapping));\n    return expr.apply(args);\n  }\n\n  private evalExistence(expr: Existence, mapping: Bindings): Term {\n    throw new UnsupportedOperation('EXISTS');\n  }\n\n  private evalAggregate(expr: Aggregate, mapping: Bindings): Term {\n    throw new UnsupportedOperation(`aggregate ${expr.name}`);\n  }\n}\n\nfunction log<T>(val: T): T {\n  // console.log(val);\n  return val;\n}\n\nexport class UnsupportedOperation extends Error {\n  constructor(operation: string) {\n    super(`Operation '${operation}' is unsupported in SimpleEvaluator`);\n  }\n}\n"]}