{"version":3,"file":"AsyncEvaluator.js","sourceRoot":"","sources":["../../../lib/evaluators/AsyncEvaluator.ts"],"names":[],"mappings":";;AAKA,sDAAqD;AAGrD,iFAAyE;AAkBzE,MAAa,cAAc;IAIzB,YAAmB,OAAuB,EAAS,SAA+B,EAAE;QAAjE,YAAO,GAAP,OAAO,CAAgB;QAAS,WAAM,GAAN,MAAM,CAA2B;QAClF,IAAI,CAAC,IAAI,GAAG,iCAAgB,CAAC,OAAO,CAAC,CAAC;QAEtC,MAAM,OAAO,GAAG;YACd,GAAG,EAAE,MAAM,CAAC,GAAG,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC;YACvC,OAAO,EAAE,MAAM,CAAC,OAAO,IAAI,SAAS;YACpC,MAAM,EAAE,MAAM,CAAC,MAAM;YACrB,SAAS,EAAE,MAAM,CAAC,SAAS;SAC5B,CAAC;QAEF,IAAI,CAAC,SAAS,GAAG,IAAI,sDAAuB,CAAC,OAAO,CAAC,CAAC;IACxD,CAAC;IAED,KAAK,CAAC,QAAQ,CAAC,OAAiB;QAC9B,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QACjE,OAAO,GAAG,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE,CAAC;IAC7B,CAAC;IAED,KAAK,CAAC,aAAa,CAAC,OAAiB;QACnC,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QACjE,OAAO,GAAG,CAAC,MAAM,CAAC,CAAC,SAAS,EAAE,CAAC;IACjC,CAAC;IAED,KAAK,CAAC,kBAAkB,CAAC,OAAiB;QACxC,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QACjE,OAAO,GAAG,CAAC,MAAM,CAAC,CAAC;IACrB,CAAC;CACF;AA/BD,wCA+BC;AAED,SAAS,GAAG,CAAI,GAAM;IACpB,oBAAoB;IACpB,OAAO,GAAG,CAAC;AACb,CAAC","sourcesContent":["import * as RDF from 'rdf-js';\nimport { Algebra as Alg } from 'sparqlalgebrajs';\n\nimport * as E from '../expressions/Expressions';\n\nimport { transformAlgebra } from '../Transformation';\nimport { Bindings, ExpressionEvaluator } from '../Types';\n\nimport { AsyncRecursiveEvaluator } from './RecursiveExpressionEvaluator';\n\ntype Expression = E.Expression;\ntype Term = E.TermExpression;\n\nexport interface AsyncEvaluatorConfig {\n  now?: Date;\n  baseIRI?: string;\n\n  exists?: (expression: Alg.ExistenceExpression, mapping: Bindings) => Promise<boolean>;\n  aggregate?: (expression: Alg.AggregateExpression) => Promise<RDF.Term>;\n  bnode?: (input?: string) => Promise<RDF.BlankNode>;\n}\n\nexport type AsyncEvaluatorContext = AsyncEvaluatorConfig & {\n  now: Date;\n};\n\nexport class AsyncEvaluator {\n  private expr: Expression;\n  private evaluator: ExpressionEvaluator<Expression, Promise<Term>>;\n\n  constructor(public algExpr: Alg.Expression, public config: AsyncEvaluatorConfig = {}) {\n    this.expr = transformAlgebra(algExpr);\n\n    const context = {\n      now: config.now || new Date(Date.now()),\n      baseIRI: config.baseIRI || undefined,\n      exists: config.exists,\n      aggregate: config.aggregate,\n    };\n\n    this.evaluator = new AsyncRecursiveEvaluator(context);\n  }\n\n  async evaluate(mapping: Bindings): Promise<RDF.Term> {\n    const result = await this.evaluator.evaluate(this.expr, mapping);\n    return log(result).toRDF();\n  }\n\n  async evaluateAsEBV(mapping: Bindings): Promise<boolean> {\n    const result = await this.evaluator.evaluate(this.expr, mapping);\n    return log(result).coerceEBV();\n  }\n\n  async evaluateAsInternal(mapping: Bindings): Promise<Term> {\n    const result = await this.evaluator.evaluate(this.expr, mapping);\n    return log(result);\n  }\n}\n\nfunction log<T>(val: T): T {\n  // console.log(val);\n  return val;\n}\n"]}