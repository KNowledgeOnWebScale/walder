{"version":3,"file":"RecursiveExpressionEvaluator.js","sourceRoot":"","sources":["../../../lib/evaluators/RecursiveExpressionEvaluator.ts"],"names":[],"mappings":"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","sourcesContent":["import * as E from '../expressions';\nimport * as Err from '../util/Errors';\n\nimport { transformRDFTermUnsafe } from '../Transformation';\nimport { Bindings, ExpressionEvaluator } from '../Types';\n\nimport { AsyncEvaluatorContext } from './AsyncEvaluator';\nimport { SyncEvaluatorContext } from './SyncEvaluator';\n\ntype Expression = E.Expression;\ntype Term = E.TermExpression;\ntype Variable = E.VariableExpression;\ntype Existence = E.ExistenceExpression;\ntype Operator = E.OperatorExpression;\ntype SpecialOperator = E.SpecialOperatorExpression;\ntype Named = E.NamedExpression;\ntype Aggregate = E.AggregateExpression;\n\nconst sharedEvaluators = {\n  term(expr: Term, mapping: Bindings): Term {\n    return expr;\n  },\n  variable(expr: Variable, mapping: Bindings): Term {\n    const term = mapping.get(expr.name);\n    if (!term) {\n      throw new Err.UnboundVariableError(expr.name, mapping);\n    }\n    return transformRDFTermUnsafe(term);\n  },\n};\n\nexport class AsyncRecursiveEvaluator implements ExpressionEvaluator<Expression, Promise<Term>> {\n\n  private readonly subEvaluators: {\n    [key: string]: (expr: Expression, mapping: Bindings) => Promise<Term> | Term;\n  } = {\n      // Shared\n      [E.ExpressionType.Term]: sharedEvaluators.term,\n      [E.ExpressionType.Variable]: sharedEvaluators.variable,\n\n      // Async\n      [E.ExpressionType.Operator]: this.evalOperator,\n      [E.ExpressionType.SpecialOperator]: this.evalSpecialOperator,\n      [E.ExpressionType.Named]: this.evalNamed,\n      [E.ExpressionType.Existence]: this.evalExistence,\n      [E.ExpressionType.Aggregate]: this.evalAggregate,\n    };\n\n  constructor(private context: AsyncEvaluatorContext) { }\n\n  async evaluate(expr: Expression, mapping: Bindings): Promise<Term> {\n    const evaluator = this.subEvaluators[expr.expressionType];\n    if (!evaluator) { throw new Err.InvalidExpressionType(expr); }\n    return evaluator.bind(this)(expr, mapping);\n  }\n\n  private async evalOperator(expr: Operator, mapping: Bindings): Promise<Term> {\n    const argPromises = expr.args.map((arg) => this.evaluate(arg, mapping));\n    const argResults = await Promise.all(argPromises);\n    return expr.apply(argResults);\n  }\n\n  private async evalSpecialOperator(expr: SpecialOperator, mapping: Bindings): Promise<Term> {\n    const evaluate = this.evaluate.bind(this);\n    const context = {\n      args: expr.args,\n      mapping,\n      evaluate,\n      context: {\n        now: this.context.now,\n        baseIRI: this.context.baseIRI,\n        bnode: this.context.bnode,\n      },\n    };\n    return expr.applyAsync(context);\n  }\n\n  private async evalNamed(expr: Named, mapping: Bindings): Promise<Term> {\n    const argPromises = expr.args.map((arg) => this.evaluate(arg, mapping));\n    const argResults = await Promise.all(argPromises);\n    return expr.apply(argResults);\n  }\n\n  private async evalExistence(expr: Existence, mapping: Bindings): Promise<Term> {\n    if (!this.context.exists) {\n      throw new Err.NoExistenceHook();\n    }\n\n    return new E.BooleanLiteral(await this\n      .context\n      .exists(expr.expression, mapping));\n  }\n\n  // TODO: Remove?\n  private async evalAggregate(expr: Aggregate, _mapping: Bindings): Promise<Term> {\n    if (!this.context.aggregate) {\n      throw new Err.NoExistenceHook();\n    }\n\n    return transformRDFTermUnsafe(await this\n      .context\n      .aggregate(expr.expression));\n  }\n}\n\nexport class SyncRecursiveEvaluator implements ExpressionEvaluator<Expression, Term> {\n\n  private readonly subEvaluators: {\n    [key: string]: (expr: Expression, mapping: Bindings) => Term;\n  } = {\n      // Shared\n      [E.ExpressionType.Term]: sharedEvaluators.term,\n      [E.ExpressionType.Variable]: sharedEvaluators.variable,\n\n      // Sync\n      [E.ExpressionType.Operator]: this.evalOperator,\n      [E.ExpressionType.SpecialOperator]: this.evalSpecialOperator,\n      [E.ExpressionType.Named]: this.evalNamed,\n      [E.ExpressionType.Existence]: this.evalExistence,\n      [E.ExpressionType.Aggregate]: this.evalAggregate,\n    };\n\n  constructor(private context: SyncEvaluatorContext) { }\n\n  evaluate(expr: Expression, mapping: Bindings): Term {\n    const evaluator = this.subEvaluators[expr.expressionType];\n    if (!evaluator) { throw new Err.InvalidExpressionType(expr); }\n    return evaluator.bind(this)(expr, mapping);\n  }\n\n  private evalOperator(expr: Operator, mapping: Bindings): Term {\n    const args = expr.args.map((arg) => this.evaluate(arg, mapping));\n    return expr.apply(args);\n  }\n\n  private evalSpecialOperator(expr: SpecialOperator, mapping: Bindings): Term {\n    const evaluate = this.evaluate.bind(this);\n    const context = {\n      args: expr.args,\n      mapping,\n      evaluate,\n      context: {\n        now: this.context.now,\n        baseIRI: this.context.baseIRI,\n        bnode: this.context.bnode,\n      },\n    };\n    return expr.applySync(context);\n  }\n\n  private evalNamed(expr: Named, mapping: Bindings): Term {\n    const args = expr.args.map((arg) => this.evaluate(arg, mapping));\n    return expr.apply(args);\n  }\n\n  private evalExistence(expr: Existence, mapping: Bindings): Term {\n    if (!this.context.exists) {\n      throw new Err.NoExistenceHook();\n    }\n\n    return new E.BooleanLiteral(this\n      .context\n      .exists(expr.expression, mapping));\n  }\n\n  private evalAggregate(expr: Aggregate, mapping: Bindings): Term {\n    if (!this.context.aggregate) {\n      throw new Err.NoAggregator();\n    }\n\n    return transformRDFTermUnsafe(this\n      .context\n      .aggregate(expr.expression));\n  }\n}\n\nexport class UnsupportedOperation extends Error {\n  constructor(operation: string) {\n    super(`Operation '${operation}' is unsupported in SimpleEvaluator`);\n  }\n}\n"]}