{"version":3,"file":"FunctionClasses.js","sourceRoot":"","sources":["../../../lib/functions/FunctionClasses.ts"],"names":[],"mappings":"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","sourcesContent":["import { List, Map } from 'immutable';\n\nimport * as E from '../expressions';\nimport * as C from '../util/Consts';\nimport * as Err from '../util/Errors';\n\ntype Term = E.TermExpression;\n\n// ----------------------------------------------------------------------------\n// Overloaded Functions\n// ----------------------------------------------------------------------------\n\n// Maps argument types on their specific implementation.\nexport type OverloadMap = Map<List<ArgumentType>, E.SimpleApplication>;\n\n// Function and operator arguments are 'flattened' in the SPARQL spec.\n// If the argument is a literal, the datatype often also matters.\nexport type ArgumentType = 'term' | E.TermType | C.Type;\n\nexport type OverloadedDefinition = {\n  arity: number | number[]\n  overloads: OverloadMap,\n};\n\nexport abstract class OverloadedFunction<Operator> {\n\n  arity: number | number[];\n  private overloads: OverloadMap;\n\n  constructor(public operator: Operator, definition: OverloadedDefinition) {\n    this.arity = definition.arity;\n    this.overloads = definition.overloads;\n  }\n\n  /**\n   * A function application works by monomorphing the function to a specific\n   * instance depending on the runtime types. We then just apply this function\n   * to the args.\n   */\n  apply = (args: Term[]): Term => {\n    const func = this.monomorph(args) || this.handleInvalidTypes(args);\n    return func(args);\n  }\n\n  protected abstract handleInvalidTypes(args: Term[]): never;\n\n  /**\n   * We monomorph by checking the map of overloads for keys corresponding\n   * to the runtime types. We start by checking for an implementation for the\n   * most concrete types (integer, string, date, IRI), if we find none,\n   * we consider their term types (literal, blank, IRI), and lastly we consider\n   * all arguments as generic terms.\n   *\n   * Another option would be to populate the overloads with an implementation\n   * for every concrete type when the function is generic over termtypes or\n   * terms.\n   */\n  private monomorph(args: Term[]) {\n    return (false\n      || this.overloads.get(Typer.asConcreteTypes(args))\n      || this.overloads.get(Typer.asTermTypes(args))\n      || this.overloads.get(Typer.asGenericTerms(args))\n    );\n  }\n}\n\nclass Typer {\n  static asConcreteTypes(args: Term[]): List<ArgumentType> {\n    // tslint:disable-next-line:no-any\n    return List(args.map((a: any) => a.type || a.termType));\n  }\n\n  static asTermTypes(args: Term[]): List<E.TermType> {\n    return List(args.map((a: E.TermExpression) => a.termType));\n  }\n\n  static asGenericTerms(args: Term[]): List<'term'> {\n    return List(Array(args.length).fill('term'));\n  }\n}\n\n// Regular Functions ----------------------------------------------------------\n\n/**\n * Varying kinds of functions take arguments of different types on which the\n * specific behaviour is dependant. Although their behaviour is often varying,\n * it is always relatively simple, and better suited for synced behaviour.\n * The types of their arguments are always terms, but might differ in\n * their term-type (eg: iri, literal),\n * their specific literal type (eg: string, integer),\n * their arity (see BNODE),\n * or even their specific numeric type (eg: integer, float).\n *\n * Examples include:\n *  - Arithmetic operations such as: *, -, /, +\n *  - Bool operators such as: =, !=, <=, <, ...\n *  - Functions such as: str, IRI\n *\n * See also: https://www.w3.org/TR/sparql11-query/#func-rdfTerms\n * and https://www.w3.org/TR/sparql11-query/#OperatorMapping\n */\nexport class RegularFunction extends OverloadedFunction<C.RegularOperator> {\n  functionClass: 'regular' = 'regular';\n\n  constructor(op: C.RegularOperator, definition: OverloadedDefinition) {\n    super(op, definition);\n  }\n\n  handleInvalidTypes(args: Term[]): never {\n    throw new Err.InvalidArgumentTypes(args, this.operator);\n  }\n}\n\n// Named Functions ------------------------------------------------------------\nexport class NamedFunction extends OverloadedFunction<C.NamedOperator> {\n  functionClass: 'named' = 'named';\n\n  constructor(op: C.NamedOperator, definition: OverloadedDefinition) {\n    super(op, definition);\n  }\n\n  handleInvalidTypes(args: Term[]): never {\n    throw new Err.InvalidArgumentTypes(args, this.operator);\n  }\n}\n\n// Special Functions ----------------------------------------------------------\n/*\n * Special Functions are those that don't really fit in sensible categories and\n * have extremely heterogeneous signatures that make them impossible to abstract\n * over. They are small in number, and their behaviour is often complex and open\n * for multiple correct implementations with different trade-offs.\n *\n * Due to their varying nature, they need all available information present\n * during evaluation. This reflects in the signature of the apply() method.\n *\n * They need access to an evaluator to be able to even implement their logic.\n * Especially relevant for IF, and the logical connectives.\n *\n * They can have both sync and async implementations, and both would make sense\n * in some contexts.\n */\nexport class SpecialFunction {\n  functionClass: 'special' = 'special';\n  arity: number;\n  applySync: E.SpecialApplicationSync;\n  applyAsync: E.SpecialApplicationAsync;\n  checkArity: (args: E.Expression[]) => boolean;\n\n  constructor(public operator: C.SpecialOperator, definition: SpecialDefinition) {\n    this.arity = definition.arity;\n    this.applySync = definition.applySync;\n    this.applyAsync = definition.applyAsync;\n    this.checkArity = definition.checkArity || defaultArityCheck(this.arity);\n  }\n}\n\nfunction defaultArityCheck(arity: number): (args: E.Expression[]) => boolean {\n  return (args: E.Expression[]): boolean => {\n    // Infinity is used to represent var-args, so it's always correct.\n    if (arity === Infinity) { return true; }\n\n    // If the function has overloaded arity, the actual arity needs to be present.\n    if (Array.isArray(arity)) {\n      return arity.indexOf(args.length) >= 0;\n    }\n\n    return args.length === arity;\n  };\n}\n\nexport type SpecialDefinition = {\n  arity: number;\n  applyAsync: E.SpecialApplicationAsync;\n  applySync: E.SpecialApplicationSync;\n  checkArity?: (args: E.Expression[]) => boolean;\n};\n"]}