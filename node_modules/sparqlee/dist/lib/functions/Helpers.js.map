{"version":3,"file":"Helpers.js","sourceRoot":"","sources":["../../../lib/functions/Helpers.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * These helpers provide a (albeit inflexible) DSL for writing function\n * definitions for the SPARQL functions.\n */\n\nimport { List, Map, Record } from 'immutable';\n\nimport * as E from '../expressions';\nimport * as C from '../util/Consts';\nimport * as Err from '../util/Errors';\n\nimport { TypeURL } from '../util/Consts';\nimport { ArgumentType, OverloadMap, promote } from './Core';\n\ntype Term = E.TermExpression;\n\nexport function declare(): Builder {\n  return new Builder();\n}\n\nexport class Builder {\n  private implementations: Impl[] = [];\n\n  collect(): OverloadMap {\n    return map(this.implementations);\n  }\n\n  log(): Builder {\n    // tslint:disable-next-line:no-console\n    console.log(this.implementations);\n    return this;\n  }\n\n  add(impl: Impl): Builder {\n    this.implementations.push(impl);\n    return this;\n  }\n\n  set(argTypes: ArgumentType[], func: E.SimpleApplication): Builder {\n    const types = List(argTypes);\n    return this.add(new Impl({ types, func }));\n  }\n\n  copy({ from, to }: { from: ArgumentType[], to: ArgumentType[] }): Builder {\n    const last = this.implementations.length - 1;\n    const _from = List(from);\n    for (let i = last; i >= 0; i--) {\n      const impl = this.implementations[i];\n      if (impl.get('types').equals(_from)) {\n        return this.set(to, impl.get('func'));\n      }\n    }\n    throw new Err.UnexpectedError(\n      'Tried to copy implementation, but types not found',\n      { from, to });\n  }\n\n  onUnary<T extends Term>(type: ArgumentType, op: (val: T) => Term) {\n    return this.set([type], ([val]: [T]) => {\n      return op(val);\n    });\n  }\n\n  onUnaryTyped<T>(type: ArgumentType, op: (val: T) => Term) {\n    return this.set([type], ([val]: [E.Literal<T>]) => {\n      return op(val.typedValue);\n    });\n  }\n\n  onBinary<L extends Term, R extends Term>(types: ArgumentType[], op: (left: L, right: R) => Term) {\n    return this.set(types, ([left, right]: [L, R]) => {\n      return op(left, right);\n    });\n  }\n\n  onBinaryTyped<L, R>(types: ArgumentType[], op: (left: L, right: R) => Term) {\n    return this.set(types, ([left, right]: [E.Literal<L>, E.Literal<R>]) => {\n      return op(left.typedValue, right.typedValue);\n    });\n  }\n\n  onTernaryTyped<A1, A2, A3>(types: ArgumentType[], op: (a1: A1, a2: A2, a3: A3) => Term) {\n    return this.set(types, ([a1, a2, a3]: [E.Literal<A1>, E.Literal<A2>, E.Literal<A3>]) => {\n      return op(a1.typedValue, a2.typedValue, a3.typedValue);\n    });\n  }\n\n  onTernary<\n    A1 extends Term,\n    A2 extends Term,\n    A3 extends Term\n  >(types: ArgumentType[], op: (a1: A1, a2: A2, a3: A3) => Term) {\n    return this.set(types, ([a1, a2, a3]: [A1, A2, A3]) => {\n      return op(a1, a2, a3);\n    });\n  }\n\n  onQuaternaryTyped<A1, A2, A3, A4>(types: ArgumentType[], op: (a1: A1, a2: A2, a3: A3, a4: A4) => Term) {\n    return this.set(types, ([a1, a2, a3, a4]: [E.Literal<A1>, E.Literal<A2>, E.Literal<A3>, E.Literal<A4>]) => {\n      return op(a1.typedValue, a2.typedValue, a3.typedValue, a4.typedValue);\n    });\n  }\n\n  unimplemented(msg: string): Builder {\n    for (let arity = 0; arity <= 5; arity++) {\n      const types = Array(arity).fill('term');\n      const func = (_args: Term[]) => { throw new Err.UnimplementedError(msg); };\n      this.set(types, func);\n    }\n    return this;\n  }\n\n  onTerm1(op: (term: Term) => Term): Builder {\n    return this.set(['term'], ([term]: [Term]) => op(term));\n  }\n\n  onLiteral1<T>(op: (lit: E.Literal<T>) => Term): Builder {\n    return this.set(['literal'], ([term]: [E.Literal<T>]) => op(term));\n  }\n\n  onBoolean1(op: (lit: E.BooleanLiteral) => Term): Builder {\n    return this\n      .set(['boolean'], ([lit]: [E.BooleanLiteral]) => op(lit));\n  }\n\n  onBoolean1Typed(op: (lit: boolean) => Term): Builder {\n    return this\n      .set(['boolean'], ([lit]: [E.BooleanLiteral]) => op(lit.typedValue));\n  }\n\n  onString1(op: (lit: E.Literal<string>) => Term): Builder {\n    return this\n      .set(['string'], ([lit]: [E.Literal<string>]) => op(lit));\n  }\n\n  onString1Typed(op: (lit: string) => Term): Builder {\n    return this\n      .set(['string'], ([lit]: [E.Literal<string>]) => op(lit.typedValue));\n  }\n\n  onLangString1(op: (lit: E.LangStringLiteral) => Term): Builder {\n    return this\n      .set(['langString'], ([lit]: [E.LangStringLiteral]) => op(lit));\n  }\n\n  onStringly1(op: (lit: E.Literal<string>) => Term): Builder {\n    return this\n      .set(['string'], ([lit]: [E.Literal<string>]) => op(lit))\n      .set(['langString'], ([lit]: [E.Literal<string>]) => op(lit));\n  }\n\n  onStringly1Typed(op: (lit: string) => Term): Builder {\n    return this\n      .set(['string'], ([lit]: [E.Literal<string>]) => op(lit.typedValue))\n      .set(['langString'], ([lit]: [E.Literal<string>]) => op(lit.typedValue));\n  }\n\n  onNumeric1(op: (val: E.NumericLiteral) => Term): Builder {\n    return this\n      .set(['integer'], ([val]: [E.NumericLiteral]) => op(val))\n      .set(['decimal'], ([val]: [E.NumericLiteral]) => op(val))\n      .set(['float'], ([val]: [E.NumericLiteral]) => op(val))\n      .set(['double'], ([val]: [E.NumericLiteral]) => op(val))\n      .invalidLexicalForm(['nonlexical'], 1);\n  }\n\n  onDateTime1(op: (date: E.DateTimeLiteral) => Term): Builder {\n    return this\n      .set(['date'], ([val]: [E.DateTimeLiteral]) => op(val))\n      .invalidLexicalForm(['nonlexical'], 1);\n  }\n\n  /**\n   * Arithmetic operators take 2 numeric arguments, and return a single numerical\n   * value. The type of the return value is heavily dependant on the types of the\n   * input arguments. In JS everything is a double, but in SPARQL it is not.\n   *\n   * {@link https://www.w3.org/TR/sparql11-query/#OperatorMapping}\n   * {@link https://www.w3.org/TR/xpath-functions/#op.numeric}\n   *\n   * @param op the (simple) binary mathematical operator that\n   */\n  arithmetic(op: (left: number, right: number) => number): Builder {\n    return this.numeric(([left, right]: E.NumericLiteral[]) => {\n      const promotionType = promote(left.type, right.type);\n      const resultType = C.decategorize(promotionType);\n      return number(op(left.typedValue, right.typedValue), resultType);\n    });\n  }\n\n  numberTest(test: (left: number, right: number) => boolean): Builder {\n    return this.numeric(([left, right]: E.NumericLiteral[]) => {\n      const result = test(left.typedValue, right.typedValue);\n      return bool(result);\n    });\n  }\n\n  stringTest(test: (left: string, right: string) => boolean): Builder {\n    return this\n      .set(\n        ['string', 'string'],\n        ([left, right]: E.StringLiteral[]) => {\n          const result = test(left.typedValue, right.typedValue);\n          return bool(result);\n        })\n      .invalidLexicalForm(['nonlexical', 'string'], 1)\n      .invalidLexicalForm(['string', 'nonlexical'], 2);\n  }\n\n  booleanTest(test: (left: boolean, right: boolean) => boolean): Builder {\n    return this\n      .set(\n        ['boolean', 'boolean'],\n        ([left, right]: E.BooleanLiteral[]) => {\n          const result = test(left.typedValue, right.typedValue);\n          return bool(result);\n        })\n      .invalidLexicalForm(['nonlexical', 'boolean'], 1)\n      .invalidLexicalForm(['boolean', 'nonlexical'], 2);\n  }\n\n  dateTimeTest(test: (left: Date, right: Date) => boolean): Builder {\n    return this\n      .set(\n        ['date', 'date'],\n        ([left, right]: E.DateTimeLiteral[]) => {\n          const result = test(left.typedValue, right.typedValue);\n          return bool(result);\n        })\n      .invalidLexicalForm(['nonlexical', 'date'], 1)\n      .invalidLexicalForm(['date', 'nonlexical'], 2);\n  }\n\n  numeric(op: E.SimpleApplication): Builder {\n    return this\n      .set(['integer', 'integer'], op)\n      .set(['integer', 'decimal'], op)\n      .set(['integer', 'float'], op)\n      .set(['integer', 'double'], op)\n      .invalidLexicalForm(['integer', 'nonlexical'], 2)\n\n      .set(['decimal', 'integer'], op)\n      .set(['decimal', 'decimal'], op)\n      .set(['decimal', 'float'], op)\n      .set(['decimal', 'double'], op)\n      .invalidLexicalForm(['decimal', 'nonlexical'], 2)\n\n      .set(['float', 'integer'], op)\n      .set(['float', 'decimal'], op)\n      .set(['float', 'float'], op)\n      .set(['float', 'double'], op)\n      .invalidLexicalForm(['float', 'nonlexical'], 2)\n\n      .set(['double', 'integer'], op)\n      .set(['double', 'decimal'], op)\n      .set(['double', 'float'], op)\n      .set(['double', 'double'], op)\n      .invalidLexicalForm(['double', 'nonlexical'], 2)\n\n      .invalidLexicalForm(['nonlexical', 'integer'], 1)\n      .invalidLexicalForm(['nonlexical', 'decimal'], 1)\n      .invalidLexicalForm(['nonlexical', 'float'], 1)\n      .invalidLexicalForm(['nonlexical', 'double'], 1);\n\n  }\n\n  invalidLexicalForm(types: ArgumentType[], index: number): Builder {\n    return this.set(types, (args: Term[]): E.TermExpression => {\n      throw new Err.InvalidLexicalForm(args[index - 1].toRDF());\n    });\n  }\n\n  private chain(impls: Impl[]): Builder {\n    this.implementations = this.implementations.concat(impls);\n    return this;\n  }\n}\n\n// ----------------------------------------------------------------------------\n// Type Safety Helpers\n// ----------------------------------------------------------------------------\n\n/**\n * Immutable.js type definitions are pretty unsafe, and this is typo-prone work.\n * These helpers allow use to create OverloadMaps with more type-safety.\n * One entry in the OverloadMap is described by the record Impl;\n *\n * A list of Impl's then gets constructed into an Immutable.js Map.\n *\n * See:\n * https://medium.com/@alexxgent/enforcing-types-with-immutablejs-and-typescript-6ab980819b6a\n */\n\nexport type ImplType = {\n  types: List<ArgumentType>;\n  func: E.SimpleApplication;\n};\n\nconst implDefaults = {\n  types: [] as ArgumentType[],\n  func() {\n    const msg = 'Implementation not set yet declared as implemented';\n    throw new Err.UnexpectedError(msg);\n  },\n};\n\nexport class Impl extends Record(implDefaults) {\n\n  constructor(params: ImplType) { super(params); }\n\n  get<T extends keyof ImplType>(value: T): ImplType[T] {\n    return super.get(value);\n  }\n\n  toPair(): [List<ArgumentType>, E.SimpleApplication] {\n    return [this.get('types'), this.get('func')];\n  }\n}\n\nexport function map(implementations: Impl[]): OverloadMap {\n  const typeImplPair = implementations.map((i) => i.toPair());\n  return Map<List<ArgumentType>, E.SimpleApplication>(typeImplPair);\n}\n\n// ----------------------------------------------------------------------------\n// Literal Construction helpers\n// ----------------------------------------------------------------------------\n\nexport function bool(val: boolean): E.BooleanLiteral {\n  return new E.BooleanLiteral(val);\n}\n\nexport function number(num: number, dt?: C.TypeURL): E.NumericLiteral {\n  return new E.NumericLiteral(num, C.make(dt || TypeURL.XSD_FLOAT), undefined);\n}\n\nexport function numberFromString(str: string, dt?: C.TypeURL): E.NumericLiteral {\n  const num = Number(str);\n  return new E.NumericLiteral(num, C.make(dt || TypeURL.XSD_FLOAT), undefined);\n}\n\nexport function string(s: string): E.StringLiteral {\n  return new E.StringLiteral(s);\n}\n\nexport function langString(s: string, lang: string) {\n  return new E.LangStringLiteral(s, lang);\n}\n\nexport function dateTime(date: Date, str: string): E.DateTimeLiteral {\n  return new E.DateTimeLiteral(date, str);\n}\n\n// ----------------------------------------------------------------------------\n// Util\n// ----------------------------------------------------------------------------\n\n// tslint:disable-next-line:no-any\nexport function log<T>(val: T, ...args: any[]): T {\n  // tslint:disable-next-line:no-console\n  console.log(val, args);\n  return val;\n}\n\nexport function typeCheckLit<T>(\n  term: E.TermExpression,\n  allowed: ArgumentType[],\n  args: E.Expression[],\n  op: C.Operator,\n): E.Literal<T> {\n\n  if (term.termType !== 'literal') {\n    throw new Err.InvalidArgumentTypes(args, op);\n  }\n\n  // tslint:disable-next-line:no-any\n  const lit = term as E.Literal<any>;\n\n  if (!allowed.includes(lit.type)) {\n    throw new Err.InvalidArgumentTypes(args, op);\n  }\n\n  return lit;\n}\n"]}