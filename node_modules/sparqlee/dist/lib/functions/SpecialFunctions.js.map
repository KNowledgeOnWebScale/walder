{"version":3,"file":"SpecialFunctions.js","sourceRoot":"","sources":["../../../lib/functions/SpecialFunctions.ts"],"names":[],"mappings":"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","sourcesContent":["import { Map } from 'immutable';\nimport * as URI from 'uri-js';\nimport * as uuid from 'uuid';\n\nimport * as E from '../expressions';\nimport * as C from '../util/Consts';\nimport * as Err from '../util/Errors';\n\nimport { Bindings } from '../Types';\nimport { bool, langString, string, typeCheckLit } from './Helpers';\nimport { regularFunctions, specialFunctions } from './index';\n\ntype Term = E.TermExpression;\ntype PTerm = Promise<E.TermExpression>;\n\n// ----------------------------------------------------------------------------\n// Functional forms\n// ----------------------------------------------------------------------------\n\nfunction _bound({ args, mapping }: { args: E.Expression[], mapping: Bindings }) {\n  const variable = args[0] as E.VariableExpression;\n  if (variable.expressionType !== E.ExpressionType.Variable) {\n    throw new Err.InvalidArgumentTypes(args, C.SpecialOperator.BOUND);\n  }\n  const val = mapping.has(variable.name) && !!mapping.get(variable.name);\n  return bool(val);\n}\n\n// BOUND ----------------------------------------------------------------------\nconst bound = {\n  arity: 1,\n  async applyAsync({ args, mapping }: E.EvalContextAsync): PTerm {\n    return _bound({ args, mapping });\n  },\n  applySync({ args, mapping }: E.EvalContextSync): Term {\n    return _bound({ args, mapping });\n  },\n};\n\n// IF -------------------------------------------------------------------------\nconst ifSPARQL = {\n  arity: 3,\n  async applyAsync({ args, mapping, evaluate }: E.EvalContextAsync): PTerm {\n    const valFirst = await evaluate(args[0], mapping);\n    const ebv = valFirst.coerceEBV();\n    return (ebv)\n      ? evaluate(args[1], mapping)\n      : evaluate(args[2], mapping);\n  },\n  applySync({ args, mapping, evaluate }: E.EvalContextSync): Term {\n    const valFirst = evaluate(args[0], mapping);\n    const ebv = valFirst.coerceEBV();\n    return (ebv)\n      ? evaluate(args[1], mapping)\n      : evaluate(args[2], mapping);\n  },\n};\n\n// COALESCE -------------------------------------------------------------------\nconst coalesce = {\n  arity: Infinity,\n  async applyAsync({ args, mapping, evaluate }: E.EvalContextAsync): PTerm {\n    const errors: Error[] = [];\n    for (const expr of args) {\n      try {\n        return await evaluate(expr, mapping);\n      } catch (err) {\n        errors.push(err);\n      }\n    }\n    throw new Err.CoalesceError(errors);\n  },\n  applySync({ args, mapping, evaluate }: E.EvalContextSync): Term {\n    const errors: Error[] = [];\n    for (const expr of args) {\n      try {\n        return evaluate(expr, mapping);\n      } catch (err) {\n        errors.push(err);\n      }\n    }\n    throw new Err.CoalesceError(errors);\n  },\n};\n\n// logical-or (||) ------------------------------------------------------------\n// https://www.w3.org/TR/sparql11-query/#func-logical-or\nconst logicalOr = {\n  arity: 2,\n  async applyAsync({ args, mapping, evaluate }: E.EvalContextAsync): PTerm {\n    const [leftExpr, rightExpr] = args;\n    try {\n      const leftTerm = await evaluate(leftExpr, mapping);\n      const left = leftTerm.coerceEBV();\n      if (left) { return bool(true); }\n      const rightTerm = await evaluate(rightExpr, mapping);\n      const right = rightTerm.coerceEBV();\n      return bool(right);\n    } catch (leftErr) {\n      const rightTerm = await evaluate(rightExpr, mapping);\n      const right = rightTerm.coerceEBV();\n      if (!right) { throw leftErr; }\n      return bool(true);\n    }\n  },\n  applySync({ args, mapping, evaluate }: E.EvalContextSync): Term {\n    const [leftExpr, rightExpr] = args;\n    try {\n      const leftTerm = evaluate(leftExpr, mapping);\n      const left = leftTerm.coerceEBV();\n      if (left) { return bool(true); }\n      const rightTerm = evaluate(rightExpr, mapping);\n      const right = rightTerm.coerceEBV();\n      return bool(right);\n    } catch (leftErr) {\n      const rightTerm = evaluate(rightExpr, mapping);\n      const right = rightTerm.coerceEBV();\n      if (!right) { throw leftErr; }\n      return bool(true);\n    }\n  },\n};\n\n// logical-and (&&) -----------------------------------------------------------\n// https://www.w3.org/TR/sparql11-query/#func-logical-and\nconst logicalAnd = {\n  arity: 2,\n  async applyAsync({ args, mapping, evaluate }: E.EvalContextAsync): PTerm {\n    const [leftExpr, rightExpr] = args;\n    try {\n      const leftTerm = await evaluate(leftExpr, mapping);\n      const left = leftTerm.coerceEBV();\n      if (!left) { return bool(false); }\n      const rightTerm = await evaluate(rightExpr, mapping);\n      const right = rightTerm.coerceEBV();\n      return bool(right);\n    } catch (leftErr) {\n      const rightTerm = await evaluate(rightExpr, mapping);\n      const right = rightTerm.coerceEBV();\n      if (right) { throw leftErr; }\n      return bool(false);\n    }\n  },\n  applySync({ args, mapping, evaluate }: E.EvalContextSync): Term {\n    const [leftExpr, rightExpr] = args;\n    try {\n      const leftTerm = evaluate(leftExpr, mapping);\n      const left = leftTerm.coerceEBV();\n      if (!left) { return bool(false); }\n      const rightTerm = evaluate(rightExpr, mapping);\n      const right = rightTerm.coerceEBV();\n      return bool(right);\n    } catch (leftErr) {\n      const rightTerm = evaluate(rightExpr, mapping);\n      const right = rightTerm.coerceEBV();\n      if (right) { throw leftErr; }\n      return bool(false);\n    }\n  },\n};\n\n// sameTerm -------------------------------------------------------------------\nconst sameTerm = {\n  arity: 2,\n  async applyAsync({ args, mapping, evaluate }: E.EvalContextAsync): PTerm {\n    const [leftExpr, rightExpr] = args.map((a) => evaluate(a, mapping));\n    const left = await leftExpr;\n    const right = await rightExpr;\n    return bool(left.toRDF().equals(right.toRDF()));\n  },\n  applySync({ args, mapping, evaluate }: E.EvalContextSync): Term {\n    const [left, right] = args.map((a) => evaluate(a, mapping));\n    return bool(left.toRDF().equals(right.toRDF()));\n  },\n};\n\n// IN -------------------------------------------------------------------------\nconst inSPARQL = {\n  arity: Infinity,\n  checkArity(args: E.Expression[]) { return args.length >= 1; },\n  async applyAsync({ args, mapping, evaluate, context }: E.EvalContextAsync): PTerm {\n    const [leftExpr, ...remaining] = args;\n    const left = await evaluate(leftExpr, mapping);\n    return inRecursiveAsync(left, { args: remaining, mapping, evaluate, context }, []);\n  },\n  applySync({ args, mapping, evaluate, context }: E.EvalContextSync): Term {\n    const [leftExpr, ...remaining] = args;\n    const left = evaluate(leftExpr, mapping);\n    return inRecursiveSync(left, { args: remaining, mapping, evaluate, context }, []);\n  },\n};\n\nasync function inRecursiveAsync(\n  needle: Term,\n  { args, mapping, evaluate, context }: E.EvalContextAsync,\n  results: Array<Error | false>,\n): PTerm {\n\n  if (args.length === 0) {\n    const noErrors = results.every((v) => !v);\n    return (noErrors) ? bool(false) : Promise.reject(new Err.InError(results));\n  }\n\n  try {\n    const next = await evaluate(args.shift(), mapping);\n    const isEqual = regularFunctions.get(C.RegularOperator.EQUAL);\n    if ((isEqual.apply([needle, next]) as E.BooleanLiteral).typedValue === true) {\n      return bool(true);\n    } else {\n      return inRecursiveAsync(needle, { args, mapping, evaluate, context }, [...results, false]);\n    }\n  } catch (err) {\n    return inRecursiveAsync(needle, { args, mapping, evaluate, context }, [...results, err]);\n  }\n}\n\nfunction inRecursiveSync(\n  needle: Term,\n  { args, mapping, evaluate, context }: E.EvalContextSync,\n  results: Array<Error | false>,\n): Term {\n\n  if (args.length === 0) {\n    const noErrors = results.every((v) => !v);\n    if (noErrors) {\n      bool(false);\n    } else {\n      throw new Err.InError(results);\n    }\n  }\n\n  try {\n    const next = evaluate(args.shift(), mapping);\n    const isEqual = regularFunctions.get(C.RegularOperator.EQUAL);\n    if ((isEqual.apply([needle, next]) as E.BooleanLiteral).typedValue === true) {\n      return bool(true);\n    } else {\n      return inRecursiveSync(needle, { args, mapping, evaluate, context }, [...results, false]);\n    }\n  } catch (err) {\n    return inRecursiveSync(needle, { args, mapping, evaluate, context }, [...results, err]);\n  }\n}\n\n// NOT IN ---------------------------------------------------------------------\nconst notInSPARQL = {\n  arity: Infinity,\n  checkArity(args: E.Expression[]) { return args.length >= 1; },\n  async applyAsync(context: E.EvalContextAsync): PTerm {\n    const _in = specialFunctions.get(C.SpecialOperator.IN);\n    const isIn = await _in.applyAsync(context);\n    return bool(!(isIn as E.BooleanLiteral).typedValue);\n  },\n  applySync(context: E.EvalContextSync): Term {\n    const _in = specialFunctions.get(C.SpecialOperator.IN);\n    const isIn = _in.applySync(context);\n    return bool(!(isIn as E.BooleanLiteral).typedValue);\n  },\n};\n\n// ----------------------------------------------------------------------------\n// Annoying functions\n// ----------------------------------------------------------------------------\n\n// CONCAT\nconst concat = {\n  arity: Infinity,\n  async applyAsync({ args, evaluate, mapping }: E.EvalContextAsync): PTerm {\n    const pLits = args\n      .map(async (expr) => evaluate(expr, mapping))\n      .map(async (pTerm) =>\n        typeCheckLit<string>(await pTerm, ['string', 'langString'], args, C.SpecialOperator.CONCAT));\n    const lits = await Promise.all(pLits);\n    const strings = lits.map((lit) => lit.typedValue);\n    const joined = strings.join('');\n    const lang = langAllEqual(lits) ? lits[0].language : undefined;\n    return (lang) ? langString(joined, lang) : string(joined);\n  },\n\n  applySync({ args, evaluate, mapping }: E.EvalContextSync): Term {\n    const lits = args\n      .map((expr) => evaluate(expr, mapping))\n      .map((pTerm) => typeCheckLit<string>(pTerm, ['string', 'langString'], args, C.SpecialOperator.CONCAT));\n    const strings = lits.map((lit) => lit.typedValue);\n    const joined = strings.join('');\n    const lang = langAllEqual(lits) ? lits[0].language : undefined;\n    return (lang) ? langString(joined, lang) : string(joined);\n  },\n};\n\nfunction langAllEqual(lits: Array<E.Literal<string>>): boolean {\n  return lits.length > 0 && lits.every((lit) => lit.language === lits[0].language);\n}\n\n// ----------------------------------------------------------------------------\n// Context dependant functions\n// ----------------------------------------------------------------------------\n\nconst now = {\n  arity: 0,\n  async applyAsync({ context }: E.EvalContextAsync): PTerm {\n    return new E.DateTimeLiteral(context.now, context.now.toUTCString());\n  },\n  applySync({ context }: E.EvalContextSync): Term {\n    return new E.DateTimeLiteral(context.now, context.now.toUTCString());\n  },\n};\n\n// https://www.w3.org/TR/sparql11-query/#func-iri\nconst IRI = {\n  arity: 1,\n  async applyAsync({ args, evaluate, mapping, context }: E.EvalContextAsync): PTerm {\n    const input = await evaluate(args[0], mapping);\n    return IRI_(input, context.baseIRI, args);\n  },\n  applySync({ args, evaluate, mapping, context }: E.EvalContextSync): Term {\n    const input = evaluate(args[0], mapping);\n    return IRI_(input, context.baseIRI, args);\n  },\n};\n\nfunction IRI_(input: Term, baseIRI: string | undefined, args: E.Expression[]): Term {\n  const lit = (input.termType !== 'namedNode')\n    ? typeCheckLit<string>(input, ['string'], args, C.SpecialOperator.IRI)\n    : input as E.NamedNode;\n\n  const iri = URI.resolve(baseIRI || '', lit.str());\n  return new E.NamedNode(iri);\n}\n\n// https://www.w3.org/TR/sparql11-query/#func-bnode\n// id has to be distinct over all id's in dataset\nconst BNODE = {\n  arity: Infinity,\n  checkArity(args: E.Expression[]) { return args.length === 0 || args.length === 1; },\n  async applyAsync({ args, evaluate, mapping, context }: E.EvalContextAsync): PTerm {\n    const input = (args.length === 1)\n      ? await evaluate(args[0], mapping)\n      : undefined;\n\n    const strInput = (input)\n      ? typeCheckLit(input, ['string'], args, C.SpecialOperator.BNODE).str()\n      : undefined;\n\n    if (context.bnode) {\n      const bnode = await context.bnode(strInput);\n      return new E.BlankNode(bnode.value);\n    }\n\n    return BNODE_(strInput);\n  },\n  applySync({ args, evaluate, mapping, context }: E.EvalContextSync): Term {\n    const input = (args.length === 1)\n      ? evaluate(args[0], mapping)\n      : undefined;\n\n    const strInput = (input)\n      ? typeCheckLit(input, ['string'], args, C.SpecialOperator.BNODE).str()\n      : undefined;\n\n    if (context.bnode) {\n      const bnode = context.bnode(strInput);\n      return new E.BlankNode(bnode.value);\n    }\n\n    return BNODE_(strInput);\n  },\n};\n\nfunction BNODE_(input?: string): E.BlankNode {\n  return new E.BlankNode('blank_' + uuid.v4());\n}\n\n// ----------------------------------------------------------------------------\n// Wrap these declarations into functions\n// ----------------------------------------------------------------------------\n\nexport type SpecialDefinition = {\n  arity: number;\n  applyAsync: E.SpecialApplicationAsync;\n  applySync: E.SpecialApplicationSync; // TODO: Test these implementations\n  checkArity?: (args: E.Expression[]) => boolean;\n};\n\nconst _specialDefinitions: { [key in C.SpecialOperator]: SpecialDefinition } = {\n  // --------------------------------------------------------------------------\n  // Functional Forms\n  // https://www.w3.org/TR/sparql11-query/#func-forms\n  // --------------------------------------------------------------------------\n  'bound': bound,\n  'if': ifSPARQL,\n  'coalesce': coalesce,\n  '&&': logicalAnd,\n  '||': logicalOr,\n  'sameterm': sameTerm,\n  'in': inSPARQL,\n  'notin': notInSPARQL,\n\n  // Annoying functions\n  'concat': concat,\n\n  // Context dependent functions\n  'now': now,\n  'iri': IRI,\n  'uri': IRI,\n  'BNODE': BNODE,\n};\n\nexport const specialDefinitions = Map<C.SpecialOperator, SpecialDefinition>(_specialDefinitions);\n"]}