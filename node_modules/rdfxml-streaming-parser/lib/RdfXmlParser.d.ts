/// <reference types="node" />
import * as RDF from "rdf-js";
import { Tag } from "sax";
import { Transform, TransformCallback } from "stream";
import EventEmitter = NodeJS.EventEmitter;
export declare class RdfXmlParser extends Transform {
    static readonly IRI_REGEX: RegExp;
    static readonly MIME_TYPE = "application/rdf+xml";
    static readonly RDF = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
    static readonly XML = "http://www.w3.org/XML/1998/namespace";
    static readonly XMLNS = "http://www.w3.org/2000/xmlns/";
    static readonly DEFAULT_NS: {
        xml: string;
    };
    static readonly FORBIDDEN_NODE_ELEMENTS: string[];
    static readonly FORBIDDEN_PROPERTY_ELEMENTS: string[];
    static readonly NCNAME_MATCHER: RegExp;
    readonly trackPosition?: boolean;
    private readonly options;
    private readonly dataFactory;
    private readonly baseIRI;
    private readonly defaultGraph?;
    private readonly strict?;
    private readonly allowDuplicateRdfIds?;
    private readonly saxStream;
    private readonly activeTagStack;
    private readonly nodeIds;
    constructor(args?: IRdfXmlParserArgs);
    /**
     * Parse the namespace of the given tag,
     * and take into account the namespace of the parent tag that was already parsed.
     * @param {Tag} tag A tag to parse the namespace from.
     * @param {IActiveTag} parentTag The parent tag, or null if this tag is the root.
     * @return {{[p: string]: string}[]} An array of namespaces,
     *                                   where the last ones have a priority over the first ones.
     */
    static parseNamespace(tag: Tag, parentTag?: IActiveTag): {
        [prefix: string]: string;
    }[];
    /**
     * Expand the given term value based on the given namespaces.
     * @param {string} term A term value.
     * @param {{[p: string]: string}[]} ns An array of namespaces,
     *                                     where the last ones have a priority over the first ones.
     * @param {RdfXmlParser} parser The RDF/XML parser instance.
     * @return {IExpandedPrefix} An expanded prefix object.
     */
    static expandPrefixedTerm(term: string, ns: {
        [key: string]: string;
    }[], parser: RdfXmlParser): IExpandedPrefix;
    /**
     * Check if the given IRI is valid.
     * @param {string} iri A potential IRI.
     * @return {boolean} If the given IRI is valid.
     */
    static isValidIri(iri: string): boolean;
    /**
     * Parses the given text stream into a quad stream.
     * @param {NodeJS.EventEmitter} stream A text stream.
     * @return {NodeJS.EventEmitter} A quad stream.
     */
    import(stream: EventEmitter): EventEmitter;
    _transform(chunk: any, encoding: string, callback: TransformCallback): void;
    /**
     * Create a new parse error instance.
     * @param {string} message An error message.
     * @return {Error} An error instance.
     */
    newParseError(message: string): Error;
    /**
     * Convert the given value to a IRI by taking into account the baseIRI.
     *
     * This will follow the RDF/XML spec for converting values with baseIRIs to a IRI.
     *
     * @param {string} value The value to convert to an IRI.
     * @param {IActiveTag} activeTag The active tag.
     * @return {NamedNode} an IRI.
     */
    valueToUri(value: string, activeTag: IActiveTag): RDF.NamedNode;
    /**
     * Convert the given value URI string to a named node.
     *
     * This throw an error if the URI is invalid.
     *
     * @param {string} uri A URI string.
     * @return {NamedNode} a named node.
     */
    uriToNamedNode(uri: string): RDF.NamedNode;
    /**
     * Validate the given value as an NCName: https://www.w3.org/TR/xml-names/#NT-NCName
     * If it is invalid, an error will thrown emitted.
     * @param {string} value A value.
     */
    validateNcname(value: string): void;
    protected attachSaxListeners(): void;
    /**
     * Handle the given tag.
     * @param {QualifiedTag} tag A SAX tag.
     */
    protected onTag(tag: Tag): void;
    /**
     * Handle the given node element in resource-mode.
     * @param {QualifiedTag} tag A SAX tag.
     * @param {IActiveTag} activeTag The currently active tag.
     * @param {IActiveTag} parentTag The parent tag or null.
     * @param {boolean} rootTag If we are currently processing the root tag.
     */
    protected onTagResource(tag: Tag, activeTag: IActiveTag, parentTag: IActiveTag, rootTag: boolean): void;
    /**
     * Handle the given property element in property-mode.
     * @param {QualifiedTag} tag A SAX tag.
     * @param {IActiveTag} activeTag The currently active tag.
     * @param {IActiveTag} parentTag The parent tag or null.
     */
    protected onTagProperty(tag: Tag, activeTag: IActiveTag, parentTag: IActiveTag): void;
    /**
     * Emit the given triple to the stream.
     * @param {Term} subject A subject term.
     * @param {Term} predicate A predicate term.
     * @param {Term} object An object term.
     * @param {Term} statementId An optional resource that identifies the triple.
     *                           If truthy, then the given triple will also be emitted reified.
     */
    protected emitTriple(subject: RDF.Term, predicate: RDF.Term, object: RDF.Term, statementId?: RDF.Term): void;
    /**
     * Register the given term as a node ID.
     * If one was already registered, this will emit an error.
     *
     * This is used to check duplicate occurrences of rdf:ID in scope of the baseIRI.
     * @param {Term} term An RDF term.
     */
    protected claimNodeId(term: RDF.Term): void;
    /**
     * Handle the given text string.
     * @param {string} text A parsed text string.
     */
    protected onText(text: string): void;
    /**
     * Handle the closing of the last tag.
     */
    protected onCloseTag(): void;
    /**
     * Fetch local DOCTYPE ENTITY's and make the parser recognise them.
     * @param {string} doctype The read doctype.
     */
    protected onDoctype(doctype: string): void;
}
export interface IExpandedPrefix {
    local: string;
    uri: string;
    prefix: string;
}
export interface IRdfXmlParserArgs {
    /**
     * A custom RDFJS DataFactory to construct terms and triples.
     */
    dataFactory?: RDF.DataFactory;
    /**
     * An initital default base IRI.
     */
    baseIRI?: string;
    /**
     * The default graph for constructing quads.
     */
    defaultGraph?: RDF.Term;
    /**
     * If the internal SAX parser should parse XML in strict mode, and error if it is invalid.
     */
    strict?: boolean;
    /**
     * If the internal position (line, column) should be tracked an emitted in error messages.
     */
    trackPosition?: boolean;
    /**
     * By default multiple occurrences of the same `rdf:ID` value are not allowed.
     * By setting this option to `true`, this uniqueness check can be disabled.
     */
    allowDuplicateRdfIds?: boolean;
}
export interface IActiveTag {
    ns?: {
        [prefix: string]: string;
    }[];
    subject?: RDF.Term;
    predicate?: RDF.Term;
    predicateEmitted?: boolean;
    predicateSubPredicates?: RDF.Term[];
    predicateSubObjects?: RDF.Term[];
    hadChildren?: boolean;
    text?: string;
    language?: string;
    datatype?: RDF.NamedNode;
    nodeId?: RDF.BlankNode;
    childrenParseType?: ParseType;
    baseIRI?: string;
    listItemCounter?: number;
    reifiedStatementId?: RDF.Term;
    childrenTagsToString?: boolean;
    childrenStringTags?: string[];
    childrenStringEmitClosingTag?: string;
    childrenCollectionSubject?: RDF.Term;
    childrenCollectionPredicate?: RDF.Term;
}
export declare enum ParseType {
    RESOURCE = 0,
    PROPERTY = 1
}
