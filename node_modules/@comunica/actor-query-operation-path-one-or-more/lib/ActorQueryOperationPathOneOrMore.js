"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const actor_abstract_path_1 = require("@comunica/actor-abstract-path");
const bus_query_operation_1 = require("@comunica/bus-query-operation");
const asynciterator_1 = require("asynciterator");
const asynciterator_promiseproxy_1 = require("asynciterator-promiseproxy");
const rdf_string_1 = require("rdf-string");
const sparqlalgebrajs_1 = require("sparqlalgebrajs");
/**
 * A comunica Path OneOrMore Query Operation Actor.
 */
class ActorQueryOperationPathOneOrMore extends actor_abstract_path_1.ActorAbstractPath {
    constructor(args) {
        super(args, sparqlalgebrajs_1.Algebra.types.ONE_OR_MORE_PATH);
    }
    async runOperation(path, context) {
        const predicate = path.predicate;
        const sVar = path.subject.termType === 'Variable';
        const oVar = path.object.termType === 'Variable';
        if (!sVar && oVar) {
            // get all the results of applying this once, then do zeroOrMore for those
            const single = actor_abstract_path_1.ActorAbstractPath.FACTORY.createPath(path.subject, predicate.path, path.object, path.graph);
            const results = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({ context, operation: single }));
            const o = rdf_string_1.termToString(path.object);
            // all branches need to share the same V to prevent duplicates
            const V = {};
            const bindingsStream = new asynciterator_1.MultiTransformIterator(results.bindingsStream);
            bindingsStream._createTransformer = (bindings) => {
                const val = bindings.get(o);
                return new asynciterator_promiseproxy_1.PromiseProxyIterator(async () => {
                    const it = new asynciterator_1.BufferedIterator();
                    await this.ALP(val, predicate.path, context, V, it, { count: 0 });
                    return it.transform({
                        transform: (item, next) => {
                            bindingsStream._push(bus_query_operation_1.Bindings({ [o]: item }));
                            next(null);
                        },
                    });
                }, { autoStart: true, maxBufferSize: 128 });
            };
            return { type: 'bindings', bindingsStream, variables: [o] };
        }
        else if (sVar && oVar) {
            throw new Error('ZeroOrMore path expressions with 2 variables not supported yet');
        }
        else if (sVar && !oVar) {
            return this.mediatorQueryOperation.mediate({
                context,
                operation: actor_abstract_path_1.ActorAbstractPath.FACTORY.createPath(path.object, actor_abstract_path_1.ActorAbstractPath.FACTORY.createOneOrMorePath(actor_abstract_path_1.ActorAbstractPath.FACTORY.createInv(predicate.path)), path.subject, path.graph),
            });
        }
        else { // if (!sVar && !oVar)
            const b = this.generateBlankNode();
            const bString = rdf_string_1.termToString(b);
            const results = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({
                context,
                operation: actor_abstract_path_1.ActorAbstractPath.FACTORY.createPath(path.subject, predicate, b, path.graph),
            }));
            const bindingsStream = results.bindingsStream.transform({
                filter: (item) => item.get(bString).equals(path.object),
                transform: (item, next) => {
                    bindingsStream._push(bus_query_operation_1.Bindings({}));
                    next(null);
                },
            });
            return { type: 'bindings', bindingsStream, variables: [] };
        }
    }
}
exports.ActorQueryOperationPathOneOrMore = ActorQueryOperationPathOneOrMore;
//# sourceMappingURL=ActorQueryOperationPathOneOrMore.js.map