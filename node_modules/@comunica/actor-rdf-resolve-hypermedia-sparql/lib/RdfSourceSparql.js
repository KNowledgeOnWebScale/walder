"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const bus_http_1 = require("@comunica/bus-http");
const bus_query_operation_1 = require("@comunica/bus-query-operation");
const data_model_1 = require("@rdfjs/data-model");
const asynciterator_1 = require("asynciterator");
const asynciterator_promiseproxy_1 = require("asynciterator-promiseproxy");
const rdf_terms_1 = require("rdf-terms");
const sparqlalgebrajs_1 = require("sparqlalgebrajs");
const sparqljson_parse_1 = require("sparqljson-parse");
class RdfSourceSparql {
    constructor(url, context, mediatorHttp) {
        this.url = url;
        this.context = context;
        this.mediatorHttp = mediatorHttp;
    }
    /**
     * Replace all blank nodes in a pattern with variables.
     * If the pattern contains no blank nodes the original pattern gets returned.
     * @param {RDF.BaseQuad} pattern A quad pattern.
     * @return {RDF.BaseQuad} A quad pattern with no blank nodes.
     */
    static replaceBlankNodes(pattern) {
        const variableNames = rdf_terms_1.getVariables(rdf_terms_1.getTerms(pattern)).map((v) => v.value);
        // track the names the blank nodes get mapped to (required if the name has to change)
        const blankMap = {};
        let changed = false;
        // for every position, convert to a variable if there is a blank node
        const result = rdf_terms_1.mapTerms(pattern, (term) => {
            if (term.termType === 'BlankNode') {
                let name = term.value;
                if (blankMap[name]) {
                    name = blankMap[name];
                }
                else {
                    if (variableNames.indexOf(name) >= 0) {
                        // increase index added to name until we find one that is available (2 loops at most)
                        let idx = 0;
                        while (variableNames.indexOf(name + idx) >= 0) {
                            ++idx;
                        }
                        name = name + idx;
                    }
                    blankMap[term.value] = name;
                    variableNames.push(name);
                }
                changed = true;
                return data_model_1.variable(name);
            }
            else {
                return term;
            }
        });
        return changed ? result : pattern;
    }
    /**
     * Convert a quad pattern to a BGP with only that pattern.
     * @param {RDF.pattern} quad A quad pattern.
     * @return {Bgp} A BGP.
     */
    static patternToBgp(pattern) {
        return RdfSourceSparql.FACTORY.createBgp([RdfSourceSparql.FACTORY
                .createPattern(pattern.subject, pattern.predicate, pattern.object, pattern.graph)]);
    }
    /**
     * Convert a quad pattern to a select query for this pattern.
     * @param {RDF.Quad} pattern A quad pattern.
     * @return {string} A select query string.
     */
    static patternToSelectQuery(pattern) {
        const variables = rdf_terms_1.getVariables(rdf_terms_1.getTerms(pattern));
        return sparqlalgebrajs_1.toSparql(RdfSourceSparql.FACTORY.createProject(RdfSourceSparql.patternToBgp(pattern), variables));
    }
    /**
     * Convert a quad pattern to a count query for the number of matching triples for this pattern.
     * @param {RDF.Quad} pattern A quad pattern.
     * @return {string} A count query string.
     */
    static patternToCountQuery(pattern) {
        return sparqlalgebrajs_1.toSparql(RdfSourceSparql.FACTORY.createProject(RdfSourceSparql.FACTORY.createExtend(RdfSourceSparql.FACTORY.createGroup(RdfSourceSparql.patternToBgp(pattern), [], [RdfSourceSparql.FACTORY.createBoundAggregate(data_model_1.variable('var0'), 'count', RdfSourceSparql.FACTORY.createTermExpression(data_model_1.namedNode('*')), false)]), data_model_1.variable('count'), RdfSourceSparql.FACTORY.createTermExpression(data_model_1.variable('var0'))), [data_model_1.variable('count')]));
    }
    /**
     * Return a new variable if the term is undefined, or the term as-is.
     * @param {Term | null} term A term or null.
     * @param {string} variableName A variable name to assign when the term was null.
     * @return {Term} A term.
     */
    static materializeOptionalTerm(term, variableName) {
        return term || data_model_1.variable(variableName);
    }
    async fetchBindingsStream(endpoint, query, context) {
        const url = endpoint + '?query=' + encodeURIComponent(query);
        // Initiate request
        const headers = new Headers();
        headers.append('Accept', 'application/sparql-results+json');
        const httpAction = { context, input: url, init: { headers } };
        const httpResponse = await this.mediatorHttp.mediate(httpAction);
        // Wrap WhatWG readable stream into a Node.js readable stream
        // If the body already is a Node.js stream (in the case of node-fetch), don't do explicit conversion.
        const responseStream = bus_http_1.ActorHttp.toNodeReadable(httpResponse.body);
        // Emit an error if the server returned an invalid response
        if (!httpResponse.ok) {
            setImmediate(() => responseStream.emit('error', new Error(`Invalid SPARQL endpoint (${endpoint}) response: ${httpResponse.statusText} (${httpResponse.status})`)));
        }
        return responseStream;
    }
    /**
     * Send a SPARQL query to a SPARQL endpoint and retrieve its bindings as a stream.
     * @param {string} endpoint A SPARQL endpoint URL.
     * @param {string} query A SPARQL query string.
     * @param {ActionContext} context An optional context.
     * @return {Promise<BindingsStream>} A promise resolving to a stream of bindings.
     */
    async queryBindings(endpoint, query, context) {
        // Parse each binding and push it in our buffered iterator
        const bindingsStream = new asynciterator_1.BufferedIterator({ autoStart: false, maxBufferSize: Infinity });
        let initialized = false;
        const superRead = bindingsStream._read;
        bindingsStream._read = (count, done) => {
            if (!initialized) {
                initialized = true;
                this.fetchBindingsStream(endpoint, query, context).then((responseStream) => {
                    const rawBindingsStream = new sparqljson_parse_1.SparqlJsonParser({ prefixVariableQuestionMark: true })
                        .parseJsonResultsStream(responseStream);
                    responseStream.on('error', (error) => rawBindingsStream.emit('error', error));
                    rawBindingsStream.on('error', (error) => bindingsStream.emit('error', error));
                    rawBindingsStream.on('data', (rawBindings) => bindingsStream._push(bus_query_operation_1.Bindings(rawBindings)));
                    rawBindingsStream.on('end', () => {
                        bindingsStream.close();
                    });
                    superRead(count, done);
                });
            }
            else {
                superRead(count, done);
            }
        };
        return bindingsStream;
    }
    match(subject, predicate, object, graph) {
        if (subject instanceof RegExp
            || predicate instanceof RegExp
            || object instanceof RegExp
            || graph instanceof RegExp) {
            throw new Error("RdfSourceSparql does not support matching by regular expressions.");
        }
        const pattern = RdfSourceSparql.replaceBlankNodes(RdfSourceSparql.FACTORY.createPattern(RdfSourceSparql.materializeOptionalTerm(subject, 's'), RdfSourceSparql.materializeOptionalTerm(predicate, 'p'), RdfSourceSparql.materializeOptionalTerm(object, 'o'), RdfSourceSparql.materializeOptionalTerm(graph, 'g')));
        const countQuery = RdfSourceSparql.patternToCountQuery(pattern);
        const selectQuery = RdfSourceSparql.patternToSelectQuery(pattern);
        // Emit metadata containing the estimated count
        this.queryBindings(this.url, countQuery, this.context)
            .then((bindingsStream) => {
            return new Promise((resolve) => {
                bindingsStream.on('data', (bindings) => {
                    const count = bindings.get('?count');
                    if (count) {
                        const totalItems = parseInt(count.value, 10);
                        if (isNaN(totalItems)) {
                            return resolve({ totalItems: Infinity });
                        }
                        return resolve({ totalItems });
                    }
                    else {
                        return resolve({ totalItems: Infinity });
                    }
                });
                bindingsStream.on('error', () => {
                    return resolve({ totalItems: Infinity });
                });
                bindingsStream.on('end', () => {
                    return resolve({ totalItems: Infinity });
                });
            });
        })
            .then((metadata) => quads.emit('metadata', metadata));
        // Materialize the queried pattern using each found binding.
        const quads = new asynciterator_promiseproxy_1.PromiseProxyIterator(async () => (await this.queryBindings(this.url, selectQuery, this.context))
            .map((bindings) => rdf_terms_1.mapTerms(pattern, (value) => {
            if (value.termType === 'Variable') {
                const boundValue = bindings.get('?' + value.value);
                if (!boundValue) {
                    quads.emit('error', new Error(`The endpoint ${this.url} failed to provide a binding for ${value.value}.`));
                }
                return boundValue;
            }
            return value;
        })));
        return quads;
    }
}
RdfSourceSparql.FACTORY = new sparqlalgebrajs_1.Factory();
exports.RdfSourceSparql = RdfSourceSparql;
//# sourceMappingURL=RdfSourceSparql.js.map