/// <reference types="node" />
import { IActionHttp, IActorHttpOutput } from "@comunica/bus-http";
import { BindingsStream } from "@comunica/bus-query-operation";
import { ActionContext, Actor, IActorTest, Mediator } from "@comunica/core";
import * as RDF from "rdf-js";
import { Algebra, Factory } from "sparqlalgebrajs";
export declare class RdfSourceSparql implements RDF.Source {
    protected static readonly FACTORY: Factory;
    private readonly url;
    private readonly context;
    private readonly mediatorHttp;
    constructor(url: string, context: ActionContext, mediatorHttp: Mediator<Actor<IActionHttp, IActorTest, IActorHttpOutput>, IActionHttp, IActorTest, IActorHttpOutput>);
    /**
     * Replace all blank nodes in a pattern with variables.
     * If the pattern contains no blank nodes the original pattern gets returned.
     * @param {RDF.BaseQuad} pattern A quad pattern.
     * @return {RDF.BaseQuad} A quad pattern with no blank nodes.
     */
    static replaceBlankNodes(pattern: RDF.BaseQuad): RDF.BaseQuad;
    /**
     * Convert a quad pattern to a BGP with only that pattern.
     * @param {RDF.pattern} quad A quad pattern.
     * @return {Bgp} A BGP.
     */
    static patternToBgp(pattern: RDF.BaseQuad): Algebra.Bgp;
    /**
     * Convert a quad pattern to a select query for this pattern.
     * @param {RDF.Quad} pattern A quad pattern.
     * @return {string} A select query string.
     */
    static patternToSelectQuery(pattern: RDF.BaseQuad): string;
    /**
     * Convert a quad pattern to a count query for the number of matching triples for this pattern.
     * @param {RDF.Quad} pattern A quad pattern.
     * @return {string} A count query string.
     */
    static patternToCountQuery(pattern: RDF.BaseQuad): string;
    /**
     * Return a new variable if the term is undefined, or the term as-is.
     * @param {Term | null} term A term or null.
     * @param {string} variableName A variable name to assign when the term was null.
     * @return {Term} A term.
     */
    static materializeOptionalTerm(term: RDF.Term | null, variableName: string): RDF.Term;
    fetchBindingsStream(endpoint: string, query: string, context: ActionContext): Promise<NodeJS.ReadableStream>;
    /**
     * Send a SPARQL query to a SPARQL endpoint and retrieve its bindings as a stream.
     * @param {string} endpoint A SPARQL endpoint URL.
     * @param {string} query A SPARQL query string.
     * @param {ActionContext} context An optional context.
     * @return {Promise<BindingsStream>} A promise resolving to a stream of bindings.
     */
    queryBindings(endpoint: string, query: string, context: ActionContext): Promise<BindingsStream>;
    match(subject?: RegExp | RDF.Term, predicate?: RegExp | RDF.Term, object?: RegExp | RDF.Term, graph?: RegExp | RDF.Term): RDF.Stream;
}
