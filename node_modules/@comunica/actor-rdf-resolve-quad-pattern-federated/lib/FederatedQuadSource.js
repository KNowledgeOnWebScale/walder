"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const bus_rdf_resolve_quad_pattern_1 = require("@comunica/bus-rdf-resolve-quad-pattern");
const DataFactory = require("@rdfjs/data-model");
const asynciterator_1 = require("asynciterator");
const asynciterator_promiseproxy_1 = require("asynciterator-promiseproxy");
const asynciterator_union_1 = require("asynciterator-union");
const sparqlalgebrajs_1 = require("sparqlalgebrajs");
/**
 * A FederatedQuadSource can evaluate quad pattern queries over the union of different heterogeneous sources.
 * It will call the given mediator to evaluate each quad pattern query separately.
 */
class FederatedQuadSource {
    constructor(mediatorResolveQuadPattern, context, emptyPatterns, skipEmptyPatterns) {
        this.mediatorResolveQuadPattern = mediatorResolveQuadPattern;
        this.sources = context.get(bus_rdf_resolve_quad_pattern_1.KEY_CONTEXT_SOURCES);
        this.contextDefault = context.delete(bus_rdf_resolve_quad_pattern_1.KEY_CONTEXT_SOURCES);
        this.emptyPatterns = emptyPatterns;
        this.skipEmptyPatterns = skipEmptyPatterns;
        this.algebraFactory = new sparqlalgebrajs_1.Factory();
        // Initialize sources in the emptyPatterns datastructure
        if (this.skipEmptyPatterns) {
            this.sources.iterator().on('data', (source) => {
                if (!this.emptyPatterns.has(source)) {
                    this.emptyPatterns.set(source, []);
                }
            });
        }
    }
    /**
     * Check if the given RDF term is not bound to an exact value.
     * I.e., if it is not a Variable.
     * @param {RDF.Term} term An RDF term.
     * @return {boolean} If it is not bound.
     */
    static isTermBound(term) {
        return term.termType !== 'Variable';
    }
    /**
     * Checks if the given (child) pattern is a more bound version of the given (parent) pattern.
     * This will also return true if the patterns are equal.
     * @param {RDF.BaseQuad} child A child pattern.
     * @param {RDF.BaseQuad} parent A parent pattern.
     * @return {boolean} If child is a sub-pattern of parent
     */
    static isSubPatternOf(child, parent) {
        return (!FederatedQuadSource.isTermBound(parent.subject) || parent.subject.equals(child.subject))
            && (!FederatedQuadSource.isTermBound(parent.predicate) || parent.predicate.equals(child.predicate))
            && (!FederatedQuadSource.isTermBound(parent.object) || parent.object.equals(child.object))
            && (!FederatedQuadSource.isTermBound(parent.graph) || parent.graph.equals(child.graph));
    }
    /**
     * Converts falsy terms to variables.
     * This is the reverse operation of {@link ActorRdfResolveQuadPatternSource#variableToNull}.
     * @param {Term} term A term or null.
     * @param {string} label The label to use if we have a variable.
     * @return {Term} A term.
     */
    static nullToVariable(term, label) {
        if (!term) {
            return DataFactory.variable('v' + label);
        }
        return term;
    }
    /**
     * If the given source is guaranteed to produce an empty result for the given pattern.
     *
     * This prediction is done based on the 'emptyPatterns' datastructure that is stored within this actor.
     * Every time an empty pattern is passed, this pattern is stored in this datastructure for this source.
     * If this pattern (or a more bound pattern) is queried, we know for certain that it will be empty again.
     * This is under the assumption that sources will remain static during query evaluation.
     *
     * @param {IQuerySource} source
     * @param {RDF.BaseQuad} pattern
     * @return {boolean}
     */
    isSourceEmpty(source, pattern) {
        if (!this.skipEmptyPatterns) {
            return false;
        }
        const emptyPatterns = this.emptyPatterns.get(source);
        if (emptyPatterns) {
            for (const emptyPattern of emptyPatterns) {
                if (FederatedQuadSource.isSubPatternOf(pattern, emptyPattern)) {
                    return true;
                }
            }
        }
        return false;
    }
    matchLazy(subject, predicate, object, graph) {
        if (subject instanceof RegExp
            || predicate instanceof RegExp
            || object instanceof RegExp
            || graph instanceof RegExp) {
            throw new Error("FederatedQuadSource does not support matching by regular expressions.");
        }
        // Counters for our metadata
        const metadata = { totalItems: 0 };
        let remainingSources = 1;
        let sourcesCount = 0;
        // Anonymous function to handle totalItems from metadata
        const checkEmitMetadata = (currentTotalItems, source, pattern, lastMetadata) => {
            if (this.skipEmptyPatterns && !currentTotalItems) {
                // Because another call may have added more information in the meantime
                if (!this.isSourceEmpty(source, pattern)) {
                    this.emptyPatterns.get(source).push(pattern);
                }
            }
            if (!remainingSources) {
                if (lastMetadata && sourcesCount === 1) {
                    // If we only had one source, emit the metadata as-is.
                    it.emit('metadata', lastMetadata);
                }
                else {
                    it.emit('metadata', metadata);
                }
            }
        };
        const sourcesIt = this.sources.iterator();
        const it = new asynciterator_union_1.RoundRobinUnionIterator(sourcesIt.map((source) => {
            remainingSources++;
            sourcesCount++;
            // If we can predict that the given source will have no bindings for the given pattern,
            // return an empty iterator.
            const pattern = this.algebraFactory.createPattern(FederatedQuadSource.nullToVariable(subject, 's'), FederatedQuadSource.nullToVariable(predicate, 'p'), FederatedQuadSource.nullToVariable(object, 'o'), FederatedQuadSource.nullToVariable(graph, 'g'));
            // Prepare the context for this specific source
            const context = this.contextDefault.set(bus_rdf_resolve_quad_pattern_1.KEY_CONTEXT_SOURCE, { type: bus_rdf_resolve_quad_pattern_1.getDataSourceType(source), value: bus_rdf_resolve_quad_pattern_1.getDataSourceValue(source) });
            return new asynciterator_promiseproxy_1.PromiseProxyIterator(async () => {
                let output;
                if (this.isSourceEmpty(source, pattern)) {
                    output = { data: new asynciterator_1.EmptyIterator(), metadata: () => Promise.resolve({ totalItems: 0 }) };
                }
                else {
                    output = await this.mediatorResolveQuadPattern.mediate({ pattern, context });
                }
                if (output.metadata) {
                    output.metadata().then((subMetadata) => {
                        if ((!subMetadata.totalItems && subMetadata.totalItems !== 0) || !isFinite(subMetadata.totalItems)) {
                            metadata.totalItems = Infinity;
                            remainingSources = 0; // We're already at infinite, so ignore any later metadata
                            checkEmitMetadata(Infinity, source, pattern, subMetadata);
                        }
                        else {
                            metadata.totalItems += subMetadata.totalItems;
                            remainingSources--;
                            checkEmitMetadata(subMetadata.totalItems, source, pattern, subMetadata);
                        }
                    });
                }
                else {
                    metadata.totalItems = Infinity;
                    remainingSources = 0; // We're already at infinite, so ignore any later metadata
                    checkEmitMetadata(Infinity, source, pattern);
                }
                return output.data;
            });
        }));
        it.on('newListener', (eventName) => {
            if (eventName === 'metadata') {
                setImmediate(() => it._fillBuffer());
            }
        });
        // If we have 0 sources, immediately emit metadata
        sourcesIt.on('end', () => {
            if (!--remainingSources) {
                it.emit('metadata', metadata);
            }
        });
        return it;
    }
    match(subject, predicate, object, graph) {
        return this.matchLazy(subject, predicate, object, graph);
    }
}
exports.FederatedQuadSource = FederatedQuadSource;
//# sourceMappingURL=FederatedQuadSource.js.map