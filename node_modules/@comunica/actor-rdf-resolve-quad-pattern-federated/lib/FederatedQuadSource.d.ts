import { DataSources, IActionRdfResolveQuadPattern, IActorRdfResolveQuadPatternOutput, IDataSource, ILazyQuadSource } from "@comunica/bus-rdf-resolve-quad-pattern";
import { ActionContext, Actor, IActorTest, Mediator } from "@comunica/core";
import { AsyncIterator } from "asynciterator";
import * as RDF from "rdf-js";
import { Factory } from "sparqlalgebrajs";
/**
 * A FederatedQuadSource can evaluate quad pattern queries over the union of different heterogeneous sources.
 * It will call the given mediator to evaluate each quad pattern query separately.
 */
export declare class FederatedQuadSource implements ILazyQuadSource {
    protected readonly mediatorResolveQuadPattern: Mediator<Actor<IActionRdfResolveQuadPattern, IActorTest, IActorRdfResolveQuadPatternOutput>, IActionRdfResolveQuadPattern, IActorTest, IActorRdfResolveQuadPatternOutput>;
    protected readonly sources: DataSources;
    protected readonly contextDefault: ActionContext;
    protected readonly emptyPatterns: Map<IDataSource, RDF.BaseQuad[]>;
    protected readonly skipEmptyPatterns: boolean;
    protected readonly algebraFactory: Factory;
    constructor(mediatorResolveQuadPattern: Mediator<Actor<IActionRdfResolveQuadPattern, IActorTest, IActorRdfResolveQuadPatternOutput>, IActionRdfResolveQuadPattern, IActorTest, IActorRdfResolveQuadPatternOutput>, context: ActionContext, emptyPatterns: Map<IDataSource, RDF.Quad[]>, skipEmptyPatterns: boolean);
    /**
     * Check if the given RDF term is not bound to an exact value.
     * I.e., if it is not a Variable.
     * @param {RDF.Term} term An RDF term.
     * @return {boolean} If it is not bound.
     */
    static isTermBound(term: RDF.Term): boolean;
    /**
     * Checks if the given (child) pattern is a more bound version of the given (parent) pattern.
     * This will also return true if the patterns are equal.
     * @param {RDF.BaseQuad} child A child pattern.
     * @param {RDF.BaseQuad} parent A parent pattern.
     * @return {boolean} If child is a sub-pattern of parent
     */
    static isSubPatternOf(child: RDF.BaseQuad, parent: RDF.BaseQuad): boolean;
    /**
     * Converts falsy terms to variables.
     * This is the reverse operation of {@link ActorRdfResolveQuadPatternSource#variableToNull}.
     * @param {Term} term A term or null.
     * @param {string} label The label to use if we have a variable.
     * @return {Term} A term.
     */
    static nullToVariable(term: RDF.Term, label: string): RDF.Term;
    /**
     * If the given source is guaranteed to produce an empty result for the given pattern.
     *
     * This prediction is done based on the 'emptyPatterns' datastructure that is stored within this actor.
     * Every time an empty pattern is passed, this pattern is stored in this datastructure for this source.
     * If this pattern (or a more bound pattern) is queried, we know for certain that it will be empty again.
     * This is under the assumption that sources will remain static during query evaluation.
     *
     * @param {IQuerySource} source
     * @param {RDF.BaseQuad} pattern
     * @return {boolean}
     */
    isSourceEmpty(source: IDataSource, pattern: RDF.BaseQuad): boolean;
    matchLazy(subject?: RegExp | RDF.Term, predicate?: RegExp | RDF.Term, object?: RegExp | RDF.Term, graph?: RegExp | RDF.Term): AsyncIterator<RDF.Quad> & RDF.Stream;
    match(subject?: RegExp | RDF.Term, predicate?: RegExp | RDF.Term, object?: RegExp | RDF.Term, graph?: RegExp | RDF.Term): RDF.Stream;
}
