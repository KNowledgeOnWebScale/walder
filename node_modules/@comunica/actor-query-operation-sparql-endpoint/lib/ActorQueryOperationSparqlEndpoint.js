"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const bus_query_operation_1 = require("@comunica/bus-query-operation");
const bus_rdf_resolve_quad_pattern_1 = require("@comunica/bus-rdf-resolve-quad-pattern");
const utils_datasource_1 = require("@comunica/utils-datasource");
const asynciterator_1 = require("asynciterator");
const fetch_sparql_endpoint_1 = require("fetch-sparql-endpoint");
const rdf_string_1 = require("rdf-string");
const sparqlalgebrajs_1 = require("sparqlalgebrajs");
/**
 * A comunica SPARQL Endpoint Query Operation Actor.
 */
class ActorQueryOperationSparqlEndpoint extends bus_query_operation_1.ActorQueryOperation {
    constructor(args) {
        super(args);
        this.endpointFetcher = new fetch_sparql_endpoint_1.SparqlEndpointFetcher({
            fetch: (input, init) => this.mediatorHttp.mediate({ input, init, context: this.lastContext }),
            prefixVariableQuestionMark: true,
        });
    }
    /**
     * Wrap a pattern in a select query.
     * @param {Operation} operation An operation.
     * @return {Project} A select query.
     */
    static patternToSelectQuery(operation) {
        if (operation.type === 'project') {
            return operation;
        }
        const variables = sparqlalgebrajs_1.Util.inScopeVariables(operation);
        return ActorQueryOperationSparqlEndpoint.FACTORY.createProject(operation, variables);
    }
    async test(action) {
        if (!action.operation) {
            throw new Error('Missing field \'operation\' in the query operation action: ' + require('util').inspect(action));
        }
        const source = await utils_datasource_1.DataSourceUtils.getSingleSource(action.context);
        if (source && bus_rdf_resolve_quad_pattern_1.getDataSourceType(source) === 'sparql') {
            return { httpRequests: 1 };
        }
        throw new Error(this.name + ' requires a single source with a \'sparql\' endpoint to be present in the context.');
    }
    async run(action) {
        const endpoint = bus_rdf_resolve_quad_pattern_1.getDataSourceValue(await utils_datasource_1.DataSourceUtils.getSingleSource(action.context));
        const selectQuery = ActorQueryOperationSparqlEndpoint.patternToSelectQuery(action.operation);
        const query = sparqlalgebrajs_1.toSparql(selectQuery);
        const bindingsStream = new asynciterator_1.BufferedIterator({ autoStart: false, maxBufferSize: Infinity });
        this.lastContext = action.context;
        this.endpointFetcher.fetchBindings(endpoint, query)
            .then((rawBindingsStream) => {
            let totalItems = 0;
            rawBindingsStream.on('error', (error) => bindingsStream.emit('error', error));
            rawBindingsStream.on('data', (rawBindings) => {
                totalItems++;
                bindingsStream._push(bus_query_operation_1.Bindings(rawBindings));
            });
            rawBindingsStream.on('end', () => {
                bindingsStream.emit('metadata', { totalItems });
                bindingsStream.close();
            });
        });
        const metadata = ActorQueryOperationSparqlEndpoint.cachifyMetadata(() => new Promise((resolve, reject) => {
            bindingsStream._fillBuffer();
            bindingsStream.on('error', reject);
            bindingsStream.on('end', () => reject(new Error('No metadata was found')));
            bindingsStream.on('metadata', resolve);
        }));
        return { type: 'bindings', metadata, bindingsStream, variables: selectQuery.variables.map(rdf_string_1.termToString) };
    }
}
ActorQueryOperationSparqlEndpoint.FACTORY = new sparqlalgebrajs_1.Factory();
exports.ActorQueryOperationSparqlEndpoint = ActorQueryOperationSparqlEndpoint;
//# sourceMappingURL=ActorQueryOperationSparqlEndpoint.js.map