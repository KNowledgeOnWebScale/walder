"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const actor_abstract_bindings_hash_1 = require("@comunica/actor-abstract-bindings-hash");
const bus_query_operation_1 = require("@comunica/bus-query-operation");
const asynciterator_promiseproxy_1 = require("asynciterator-promiseproxy");
/**
 * A comunica Minus Query Operation Actor.
 */
class ActorQueryOperationMinus extends actor_abstract_bindings_hash_1.AbstractFilterHash {
    constructor(args) {
        super(args, 'minus');
    }
    newHashFilter(hashAlgorithm, digestAlgorithm, commons, hashes) {
        return (bindings) => {
            const hash = ActorQueryOperationMinus.hash(hashAlgorithm, digestAlgorithm, bindings.filter((v, k) => commons[k]));
            return !(hash in hashes);
        };
    }
    async runOperation(pattern, context) {
        const buffer = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({ operation: pattern.right, context }));
        const output = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({ operation: pattern.left, context }));
        const commons = this.getCommonVariables(buffer.variables, output.variables);
        if (Object.keys(commons).length !== 0) {
            const hashes = {};
            /**
             * To assure we've filtered all B (`buffer`) values from A (`output`) we wait until we've fetched all values of B.
             * Then we save these triples in a hashmap `hashes` and use the map to filter our A-stream.
             */
            const bindingsStream = new asynciterator_promiseproxy_1.PromiseProxyIterator(async () => {
                await new Promise((resolve) => {
                    buffer.bindingsStream.on('data', (data) => {
                        const hash = ActorQueryOperationMinus.hash(this.hashAlgorithm, this.digestAlgorithm, data.filter((v, k) => commons[k]));
                        hashes[hash] = true;
                    });
                    buffer.bindingsStream.on('end', () => {
                        resolve();
                    });
                });
                return output.bindingsStream.filter(this.newHashFilter(this.hashAlgorithm, this.digestAlgorithm, commons, hashes));
            });
            return { type: 'bindings', bindingsStream, variables: output.variables, metadata: output.metadata };
        }
        else {
            return output;
        }
    }
    /**
     * This function puts all common values between 2 arrays in a map with `value` : true
     */
    getCommonVariables(array1, array2) {
        return array1.filter((n) => -1 !== array2.indexOf(n))
            .reduce((m, key) => { m[key] = true; return m; }, {});
    }
}
exports.ActorQueryOperationMinus = ActorQueryOperationMinus;
//# sourceMappingURL=ActorQueryOperationMinus.js.map