"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const stream_1 = require("stream");
/**
 * An HTML parse listeners that detects <script> data blocks with known RDF media tyoes,
 * parses them, and outputs the resulting quads.
 */
class HtmlScriptListener {
    constructor(mediatorRdfParseHandle, cbQuad, cbError, cbEnd, supportedTypes, context, baseIRI) {
        this.handleMediaType = null;
        this.textChunks = null;
        this.endBarrier = 1;
        this.mediatorRdfParseHandle = mediatorRdfParseHandle;
        this.cbQuad = cbQuad;
        this.cbError = cbError;
        this.cbEnd = cbEnd;
        this.supportedTypes = supportedTypes;
        this.context = context;
        this.baseIRI = baseIRI;
    }
    onEnd() {
        if (--this.endBarrier === 0) {
            this.cbEnd();
        }
    }
    onTagClose() {
        if (this.handleMediaType) {
            // Create a temporary text stream for pushing all the text chunks
            const textStream = new stream_1.Readable({ objectMode: true });
            textStream._read = () => { return; };
            const textChunksLocal = this.textChunks;
            // Send all collected text to parser
            const parseAction = {
                context: this.context,
                handle: { baseIRI: this.baseIRI, input: textStream },
                handleMediaType: this.handleMediaType,
            };
            this.mediatorRdfParseHandle.mediate(parseAction).then(({ handle }) => {
                // Initialize text parsing
                handle.quads
                    .on('error', this.cbError)
                    .on('data', this.cbQuad)
                    .on('end', () => this.onEnd());
                // Push the text stream after all events have been attached
                for (const textChunk of textChunksLocal) {
                    textStream.push(textChunk);
                }
                textStream.push(null);
            });
            // Reset the media type and text stream
            this.handleMediaType = null;
            this.textChunks = null;
        }
    }
    onTagOpen(name, attributes) {
        // Only handle script tags with a parseable content type
        if (name === 'script' && this.supportedTypes[attributes.type]) {
            this.handleMediaType = attributes.type;
            this.textChunks = [];
            this.endBarrier++;
        }
        else {
            this.handleMediaType = null;
        }
    }
    onText(data) {
        if (this.handleMediaType) {
            this.textChunks.push(data);
        }
    }
}
exports.HtmlScriptListener = HtmlScriptListener;
//# sourceMappingURL=HtmlScriptListener.js.map