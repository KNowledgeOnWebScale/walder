"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const asynciterator_1 = require("asynciterator");
const asynciterator_promiseproxy_1 = require("asynciterator-promiseproxy");
const rdf_string_1 = require("rdf-string");
const rdf_terms_1 = require("rdf-terms");
/**
 * An RDF source that executes a quad pattern over a QPF interface and fetches its first page.
 */
class RdfSourceQpf {
    constructor(mediatorMetadata, mediatorMetadataExtract, mediatorRdfDereference, subjectUri, predicateUri, objectUri, graphUri, metadata, context, initialQuads) {
        this.mediatorMetadata = mediatorMetadata;
        this.mediatorMetadataExtract = mediatorMetadataExtract;
        this.mediatorRdfDereference = mediatorRdfDereference;
        this.subjectUri = subjectUri;
        this.predicateUri = predicateUri;
        this.objectUri = objectUri;
        this.graphUri = graphUri;
        this.context = context;
        this.cachedQuads = {};
        this.searchForm = this.getSearchForm(metadata);
        if (initialQuads) {
            const wrappedQuads = asynciterator_1.AsyncIterator.wrap(initialQuads);
            wrappedQuads.setProperty('metadata', metadata);
            this.cacheQuads(wrappedQuads);
        }
    }
    /**
     * Get a first QPF search form.
     * @param {{[p: string]: any}} metadata A metadata object.
     * @return {ISearchForm} A search form, or null if none could be found.
     */
    getSearchForm(metadata) {
        if (!metadata.searchForms || !metadata.searchForms.values) {
            return null;
        }
        // Find a quad pattern or triple pattern search form
        const searchForms = metadata.searchForms;
        // TODO: in the future, a query-based search form getter should be used.
        for (const searchForm of searchForms.values) {
            if (this.graphUri
                && this.subjectUri in searchForm.mappings
                && this.predicateUri in searchForm.mappings
                && this.objectUri in searchForm.mappings
                && this.graphUri in searchForm.mappings
                && Object.keys(searchForm.mappings).length === 4) {
                return searchForm;
            }
            if (this.subjectUri in searchForm.mappings
                && this.predicateUri in searchForm.mappings
                && this.objectUri in searchForm.mappings
                && Object.keys(searchForm.mappings).length === 3) {
                return searchForm;
            }
        }
        return null;
    }
    /**
     * Create a QPF fragment IRI for the given quad pattern.
     * @param {ISearchForm} searchForm A search form.
     * @param {Term} subject A term or null.
     * @param {Term} predicate A term or null.
     * @param {Term} object A term or null.
     * @param {Term} graph A term or null.
     * @return {string} A URI.
     */
    createFragmentUri(searchForm, subject, predicate, object, graph) {
        const entries = {};
        const input = [
            { uri: this.subjectUri, term: subject },
            { uri: this.predicateUri, term: predicate },
            { uri: this.objectUri, term: object },
            { uri: this.graphUri, term: graph },
        ];
        for (const entry of input) {
            if (entry.uri && entry.term) {
                entries[entry.uri] = rdf_string_1.termToString(entry.term);
            }
        }
        return searchForm.getUri(entries);
    }
    /**
     * A helper function to find a hash with quad elements that have duplicate variables.
     *
     * @param {RDF.Term} subject An optional subject term.
     * @param {RDF.Term} predicate An optional predicate term.
     * @param {RDF.Term} object An optional object term.
     * @param {RDF.Term} graph An optional graph term.
     *
     * @return {{[p: string]: string[]}} If no equal variable names are present in the four terms, this returns null.
     *                                   Otherwise, this maps quad elements ('subject', 'predicate', 'object', 'graph')
     *                                   to the list of quad elements it shares a variable name with.
     *                                   If no links for a certain element exist, this element will
     *                                   not be included in the hash.
     *                                   Note 1: Quad elements will never have a link to themselves.
     *                                           So this can never occur: { subject: [ 'subject'] },
     *                                           instead 'null' would be returned.
     *                                   Note 2: Links only exist in one direction,
     *                                           this means that { subject: [ 'predicate'], predicate: [ 'subject' ] }
     *                                           will not occur, instead only { subject: [ 'predicate'] }
     *                                           will be returned.
     */
    getDuplicateElementLinks(subject, predicate, object, graph) {
        // Collect a variable to quad elements mapping.
        const variableElements = {};
        let duplicateVariables = false;
        const input = { subject, predicate, object, graph };
        for (const key in input) {
            if (input[key] && input[key].termType === 'Variable') {
                const val = rdf_string_1.termToString(input[key]);
                const length = (variableElements[val] || (variableElements[val] = [])).push(key);
                duplicateVariables = duplicateVariables || length > 1;
            }
        }
        if (!duplicateVariables) {
            return null;
        }
        // Collect quad element to elements with equal variables mapping.
        const duplicateElementLinks = {};
        for (const variable in variableElements) {
            const elements = variableElements[variable];
            const remainingElements = elements.slice(1);
            // Only store the elements that have at least one equal element.
            if (remainingElements.length) {
                duplicateElementLinks[elements[0]] = remainingElements;
            }
        }
        return duplicateElementLinks;
    }
    match(subject, predicate, object, graph) {
        if (subject instanceof RegExp
            || predicate instanceof RegExp
            || object instanceof RegExp
            || graph instanceof RegExp) {
            throw new Error("RdfSourceQpf does not support matching by regular expressions.");
        }
        // Try to emit from cache
        const cached = this.getCachedQuads(subject, predicate, object, graph);
        if (cached) {
            return cached;
        }
        const quads = new asynciterator_promiseproxy_1.PromiseProxyIterator(async () => {
            let url = await this.createFragmentUri(this.searchForm, subject, predicate, object, graph);
            const rdfDereferenceOutput = await this.mediatorRdfDereference.mediate({ context: this.context, url });
            url = rdfDereferenceOutput.url;
            // Determine the metadata and emit it
            const rdfMetadataOuput = await this.mediatorMetadata.mediate({ context: this.context, url, quads: rdfDereferenceOutput.quads, triples: rdfDereferenceOutput.triples });
            this.mediatorMetadataExtract
                .mediate({ context: this.context, url, metadata: rdfMetadataOuput.metadata })
                .then(({ metadata }) => {
                quads.setProperty('metadata', metadata);
                quads.emit('metadata', metadata);
            });
            // The server is free to send any data in its response (such as metadata),
            // including quads that do not match the given matter.
            // Therefore, we have to filter away all non-matching quads here.
            let filteredOutput = asynciterator_1.AsyncIterator.wrap(rdfMetadataOuput.data)
                .filter((quad) => rdf_terms_1.matchPattern(quad, subject, predicate, object, graph));
            // Detect duplicate variables in the pattern
            const duplicateElementLinks = this
                .getDuplicateElementLinks(subject, predicate, object, graph);
            // If there are duplicate variables in the search pattern,
            // make sure that we filter out the triples that don't have equal values for those triple elements,
            // as QPF ignores variable names.
            if (duplicateElementLinks) {
                filteredOutput = filteredOutput.filter((quad) => {
                    // No need to check the graph, because an equal element already would have to be found in s, p, or o.
                    for (const element1 of rdf_terms_1.TRIPLE_TERM_NAMES) {
                        for (const element2 of (duplicateElementLinks[element1] || [])) {
                            if (!quad[element1].equals(quad[element2])) {
                                return false;
                            }
                        }
                    }
                    return true;
                });
            }
            return filteredOutput;
        });
        this.cacheQuads(quads, subject, predicate, object, graph);
        return this.getCachedQuads(subject, predicate, object, graph);
    }
    getPatternId(subject, predicate, object, graph) {
        // tslint:disable:object-literal-sort-keys
        return JSON.stringify({
            s: rdf_string_1.termToString(subject),
            p: rdf_string_1.termToString(predicate),
            o: rdf_string_1.termToString(object),
            g: rdf_string_1.termToString(graph),
        });
        // tslint:enable:object-literal-sort-keys
    }
    cacheQuads(quads, subject, predicate, object, graph) {
        const patternId = this.getPatternId(subject, predicate, object, graph);
        this.cachedQuads[patternId] = quads.clone();
    }
    getCachedQuads(subject, predicate, object, graph) {
        const patternId = this.getPatternId(subject, predicate, object, graph);
        let quads = this.cachedQuads[patternId];
        if (quads) {
            const quadsOriginal = quads;
            // Make our iterator lazy to ensure that metadata event is emitted before end event.
            quads = new asynciterator_promiseproxy_1.PromiseProxyIterator(async () => quadsOriginal.clone());
            quadsOriginal.getProperty('metadata', (metadata) => quads.emit('metadata', metadata));
            return quads;
        }
        return null;
    }
}
exports.RdfSourceQpf = RdfSourceQpf;
//# sourceMappingURL=RdfSourceQpf.js.map