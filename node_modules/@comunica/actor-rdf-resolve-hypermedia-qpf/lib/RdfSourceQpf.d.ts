import { ISearchForm } from "@comunica/actor-rdf-metadata-extract-hydra-controls";
import { IActionRdfDereference, IActorRdfDereferenceOutput } from "@comunica/bus-rdf-dereference";
import { IActionRdfMetadata, IActorRdfMetadataOutput } from "@comunica/bus-rdf-metadata";
import { IActionRdfMetadataExtract, IActorRdfMetadataExtractOutput } from "@comunica/bus-rdf-metadata-extract";
import { ActionContext, Actor, IActorTest, Mediator } from "@comunica/core";
import { AsyncIterator } from "asynciterator";
import * as RDF from "rdf-js";
/**
 * An RDF source that executes a quad pattern over a QPF interface and fetches its first page.
 */
export declare class RdfSourceQpf implements RDF.Source {
    readonly searchForm: ISearchForm;
    private readonly mediatorMetadata;
    private readonly mediatorMetadataExtract;
    private readonly mediatorRdfDereference;
    private readonly subjectUri;
    private readonly predicateUri;
    private readonly objectUri;
    private readonly graphUri?;
    private readonly context;
    private readonly cachedQuads;
    constructor(mediatorMetadata: Mediator<Actor<IActionRdfMetadata, IActorTest, IActorRdfMetadataOutput>, IActionRdfMetadata, IActorTest, IActorRdfMetadataOutput>, mediatorMetadataExtract: Mediator<Actor<IActionRdfMetadataExtract, IActorTest, IActorRdfMetadataExtractOutput>, IActionRdfMetadataExtract, IActorTest, IActorRdfMetadataExtractOutput>, mediatorRdfDereference: Mediator<Actor<IActionRdfDereference, IActorTest, IActorRdfDereferenceOutput>, IActionRdfDereference, IActorTest, IActorRdfDereferenceOutput>, subjectUri: string, predicateUri: string, objectUri: string, graphUri: string, metadata: {
        [id: string]: any;
    }, context: ActionContext, initialQuads?: RDF.Stream);
    /**
     * Get a first QPF search form.
     * @param {{[p: string]: any}} metadata A metadata object.
     * @return {ISearchForm} A search form, or null if none could be found.
     */
    getSearchForm(metadata: {
        [id: string]: any;
    }): ISearchForm;
    /**
     * Create a QPF fragment IRI for the given quad pattern.
     * @param {ISearchForm} searchForm A search form.
     * @param {Term} subject A term or null.
     * @param {Term} predicate A term or null.
     * @param {Term} object A term or null.
     * @param {Term} graph A term or null.
     * @return {string} A URI.
     */
    createFragmentUri(searchForm: ISearchForm, subject: RDF.Term, predicate: RDF.Term, object: RDF.Term, graph: RDF.Term): string;
    /**
     * A helper function to find a hash with quad elements that have duplicate variables.
     *
     * @param {RDF.Term} subject An optional subject term.
     * @param {RDF.Term} predicate An optional predicate term.
     * @param {RDF.Term} object An optional object term.
     * @param {RDF.Term} graph An optional graph term.
     *
     * @return {{[p: string]: string[]}} If no equal variable names are present in the four terms, this returns null.
     *                                   Otherwise, this maps quad elements ('subject', 'predicate', 'object', 'graph')
     *                                   to the list of quad elements it shares a variable name with.
     *                                   If no links for a certain element exist, this element will
     *                                   not be included in the hash.
     *                                   Note 1: Quad elements will never have a link to themselves.
     *                                           So this can never occur: { subject: [ 'subject'] },
     *                                           instead 'null' would be returned.
     *                                   Note 2: Links only exist in one direction,
     *                                           this means that { subject: [ 'predicate'], predicate: [ 'subject' ] }
     *                                           will not occur, instead only { subject: [ 'predicate'] }
     *                                           will be returned.
     */
    getDuplicateElementLinks(subject?: RDF.Term, predicate?: RDF.Term, object?: RDF.Term, graph?: RDF.Term): {
        [element: string]: string[];
    };
    match(subject?: RegExp | RDF.Term, predicate?: RegExp | RDF.Term, object?: RegExp | RDF.Term, graph?: RegExp | RDF.Term): RDF.Stream;
    protected getPatternId(subject?: RDF.Term, predicate?: RDF.Term, object?: RDF.Term, graph?: RDF.Term): string;
    protected cacheQuads(quads: AsyncIterator<RDF.Quad>, subject?: RDF.Term, predicate?: RDF.Term, object?: RDF.Term, graph?: RDF.Term): void;
    protected getCachedQuads(subject?: RDF.Term, predicate?: RDF.Term, object?: RDF.Term, graph?: RDF.Term): AsyncIterator<RDF.Quad>;
}
