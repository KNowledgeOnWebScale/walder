"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const asynciterator_1 = require("asynciterator");
const ActorRdfResolveQuadPattern_1 = require("./ActorRdfResolveQuadPattern");
/**
 * A base implementation for rdf-resolve-quad-pattern events
 * that wraps around an RDFJS {@link RDF.Source}.
 *
 * @see RDF.Source
 */
class ActorRdfResolveQuadPatternSource extends ActorRdfResolveQuadPattern_1.ActorRdfResolveQuadPattern {
    constructor(args) {
        super(args);
    }
    static variableToNull(term) {
        if (term && term.termType === 'Variable') {
            return null;
        }
        return term;
    }
    /**
     * Convert a metadata callback to a lazy callback where the response value is cached.
     * @param {() => Promise<{[p: string]: any}>} metadata A metadata callback
     * @return {() => Promise<{[p: string]: any}>} The callback where the response will be cached.
     */
    static cachifyMetadata(metadata) {
        let lastReturn = null;
        return () => (lastReturn || (lastReturn = metadata()));
    }
    async test(action) {
        return true;
    }
    async run(action) {
        const source = await this.getSource(action.context, action.pattern);
        return await this.getOutput(source, action.pattern, action.context);
    }
    /**
     * Get the metadata of the given action on a source.
     *
     * By default, this method is implemented by listening to the 'metadata' event
     * in the data stream, and resolving the promise to its value.
     *
     * @param {RDF.Source} source An RDFJS source, possibly lazy.
     * @param {Algebra.Operation} operation The operation to apply.
     * @param ActionContext context Optional context data.
     * @param {AsyncIterator<Quad> & Stream} data The data stream that was created by
     *                                            executing source.matchLazy or source.match.
     * @return {() => Promise<{[p: string]: any}>} A lazy promise behind a callback resolving to a metadata object.
     */
    getMetadata(source, pattern, context, data) {
        return () => new Promise((resolve, reject) => {
            data.on('error', reject);
            data.on('end', () => resolve({}));
            data.on('metadata', (metadata) => {
                resolve(metadata);
            });
        });
    }
    /**
     * Get the output of the given action on a source.
     * @param {RDF.Source} source An RDFJS source, possibly lazy.
     * @param {Algebra.Operation} operation The operation to apply.
     * @param ActionContext context Optional context data.
     * @return {Promise<IActorRdfResolveQuadPatternOutput>} A promise that resolves to a hash containing
     *                                                      a data RDFJS stream and an optional metadata hash.
     */
    async getOutput(source, pattern, context) {
        // Create data stream
        let data;
        if (source.matchLazy) {
            data = source.matchLazy(ActorRdfResolveQuadPatternSource.variableToNull(pattern.subject), ActorRdfResolveQuadPatternSource.variableToNull(pattern.predicate), ActorRdfResolveQuadPatternSource.variableToNull(pattern.object), ActorRdfResolveQuadPatternSource.variableToNull(pattern.graph));
        }
        else {
            // TODO: AsyncIterator fix typings
            data = asynciterator_1.AsyncIterator.wrap(source.match(ActorRdfResolveQuadPatternSource.variableToNull(pattern.subject), ActorRdfResolveQuadPatternSource.variableToNull(pattern.predicate), ActorRdfResolveQuadPatternSource.variableToNull(pattern.object), ActorRdfResolveQuadPatternSource.variableToNull(pattern.graph)));
        }
        // Create metadata callback
        const metadata = ActorRdfResolveQuadPatternSource.cachifyMetadata(this.getMetadata(source, pattern, context, data));
        return { data, metadata };
    }
}
exports.ActorRdfResolveQuadPatternSource = ActorRdfResolveQuadPatternSource;
//# sourceMappingURL=ActorRdfResolveQuadPatternSource.js.map