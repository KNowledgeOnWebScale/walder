"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const bus_query_operation_1 = require("@comunica/bus-query-operation");
const data_model_1 = require("@rdfjs/data-model");
const asynciterator_1 = require("asynciterator");
const rdf_string_1 = require("rdf-string");
const sparqlalgebrajs_1 = require("sparqlalgebrajs");
/**
 * An abstract actor that handles Path operations.
 *
 * Provides multiple helper functions used by the Path operation actors.
 */
class ActorAbstractPath extends bus_query_operation_1.ActorQueryOperationTypedMediated {
    constructor(args, predicateType) {
        super(args, 'path');
        this.predicateType = predicateType;
    }
    async testOperation(pattern, context) {
        if (pattern.predicate.type !== this.predicateType) {
            throw new Error('This Actor only supports ' + this.predicateType + ' Path operations.');
        }
        return true;
    }
    // generates a blank node that does not yet occur in the path
    generateBlankNode(path, name) {
        if (!name) {
            return this.generateBlankNode(path, 'b');
        }
        // path predicates can't contain variables/blank nodes
        if (path && (path.subject.value === name || path.object.value === name)) {
            return this.generateBlankNode(path, name + 'b');
        }
        return data_model_1.blankNode(name);
    }
    // based on definition in spec https://www.w3.org/TR/sparql11-query/
    // returns all nodes visited by infinitely repeating the given predicate, starting from x
    async ALPeval(x, predicate, context) {
        const it = new asynciterator_1.BufferedIterator();
        await this.ALP(x, predicate, context, {}, it, { count: 0 });
        return it;
    }
    async ALP(x, predicate, context, V, it, counter) {
        const s = rdf_string_1.termToString(x);
        if (V[s]) {
            return;
        }
        it._push(x);
        V[s] = x;
        const b = this.generateBlankNode();
        const bString = rdf_string_1.termToString(b);
        const path = ActorAbstractPath.FACTORY.createPath(x, predicate, b);
        const results = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({ operation: path, context }));
        counter.count++;
        results.bindingsStream.on('data', async (bindings) => {
            const result = bindings.get(bString);
            await this.ALP(result, predicate, context, V, it, counter);
        });
        results.bindingsStream.on('end', () => {
            if (--counter.count === 0) {
                it.close();
            }
        });
    }
}
ActorAbstractPath.FACTORY = new sparqlalgebrajs_1.Factory();
exports.ActorAbstractPath = ActorAbstractPath;
//# sourceMappingURL=ActorAbstractPath.js.map