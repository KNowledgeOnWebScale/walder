import { BufferedIterator, BufferedIteratorOptions } from "asynciterator";
import LRUCache = require("lru-cache");
import * as RDF from "rdf-js";
/**
 * An abstract quad iterator that can iterate over consecutive RDF sources.
 *
 * This iterator stores a queue of sources that need to be iterated over.
 * For each source, its collected metadata is maintained.
 */
export declare abstract class LinkedRdfSourcesAsyncRdfIterator extends BufferedIterator<RDF.Quad> implements RDF.Stream {
    sourcesState: ISourcesState;
    protected readonly subject: RDF.Term;
    protected readonly predicate: RDF.Term;
    protected readonly object: RDF.Term;
    protected readonly graph: RDF.Term;
    protected sourceStates: ISourceState[];
    protected nextSource: ISourceState;
    private readonly cacheSize;
    private readonly firstUrl;
    private started;
    private iterating;
    constructor(cacheSize: number, subject: RDF.Term, predicate: RDF.Term, object: RDF.Term, graph: RDF.Term, firstUrl: string, options?: BufferedIteratorOptions);
    /**
     * This method can optionally called after constructing an instance
     * for allowing the sources state to be cached.
     *
     * When calling without args, then the default logic will be followed to determine the sources state.
     * When calling with an arg, then the given sources state will be set instead of following the default logic.
     *
     * After calling this method, the `sourcesState` field can be retrieved and optionally cached.
     *
     * This sources state also contains a hash of all handled datasets that will be copied upon first use.
     *
     * @param {ISourcesState} sourcesState An optional sources state.
     */
    setSourcesState(sourcesState?: ISourcesState): void;
    _read(count: number, done: () => void): void;
    protected abstract getNextUrls(metadata: {
        [id: string]: any;
    }): Promise<string[]>;
    protected abstract getNextSource(url: string, handledDatasets: {
        [type: string]: boolean;
    }): Promise<ISourceState>;
    protected getNextSourceCached(url: string, handledDatasets: {
        [type: string]: boolean;
    }): Promise<ISourceState>;
    /**
     * Start a new iterator for the given source.
     * Once the iterator is done, it will either determine a new source, or it will close the iterator.
     * @param {ISourceState} startSource The start source state.
     * @param {boolean} emitMetadata If the metadata event should be emitted.
     */
    protected startIterator(startSource: ISourceState, emitMetadata: boolean): void;
}
/**
 * A reusable sources state,
 * containing a cache of all source states.
 */
export interface ISourcesState {
    /**
     * A cache for source URLs to source states.
     */
    sources: LRUCache<string, Promise<ISourceState>>;
}
/**
 * The current state of a source.
 * This is needed for following links within a source.
 */
export interface ISourceState {
    /**
     * A source.
     */
    source: RDF.Source;
    /**
     * The source's initial metadata.
     */
    metadata: {
        [id: string]: any;
    };
    /**
     * All dataset identifiers that have been passed for this source.
     */
    handledDatasets: {
        [type: string]: boolean;
    };
}
