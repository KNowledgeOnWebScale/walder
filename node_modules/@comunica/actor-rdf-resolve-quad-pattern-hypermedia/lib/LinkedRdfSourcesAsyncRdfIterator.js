"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const asynciterator_1 = require("asynciterator");
const LRUCache = require("lru-cache");
/**
 * An abstract quad iterator that can iterate over consecutive RDF sources.
 *
 * This iterator stores a queue of sources that need to be iterated over.
 * For each source, its collected metadata is maintained.
 */
class LinkedRdfSourcesAsyncRdfIterator extends asynciterator_1.BufferedIterator {
    constructor(cacheSize, subject, predicate, object, graph, firstUrl, options) {
        super(options);
        this.cacheSize = cacheSize;
        this.subject = subject;
        this.predicate = predicate;
        this.object = object;
        this.graph = graph;
        this.sourceStates = [];
        this.firstUrl = firstUrl;
        this.started = false;
        this.iterating = false;
    }
    /**
     * This method can optionally called after constructing an instance
     * for allowing the sources state to be cached.
     *
     * When calling without args, then the default logic will be followed to determine the sources state.
     * When calling with an arg, then the given sources state will be set instead of following the default logic.
     *
     * After calling this method, the `sourcesState` field can be retrieved and optionally cached.
     *
     * This sources state also contains a hash of all handled datasets that will be copied upon first use.
     *
     * @param {ISourcesState} sourcesState An optional sources state.
     */
    setSourcesState(sourcesState) {
        if (sourcesState) {
            this.sourcesState = sourcesState;
        }
        else {
            this.sourcesState = {
                sources: new LRUCache({ max: this.cacheSize }),
            };
            this.getNextSourceCached(this.firstUrl, {}); // Ignore the response, we just want the promise to be cached
        }
    }
    _read(count, done) {
        if (!this.started) {
            this.started = true;
            if (!this.sourcesState) {
                this.setSourcesState();
            }
            this.sourcesState.sources.get(this.firstUrl)
                .then((sourceState) => {
                this.startIterator(sourceState, true);
                done();
            })
                .catch((e) => this.emit('error', e));
        }
        else if (!this.iterating && this.nextSource) {
            const nextSource = this.nextSource;
            this.nextSource = null;
            this.getNextUrls(nextSource.metadata)
                .then((nextUrls) => Promise.all(nextUrls
                .map((nextUrl) => this.getNextSourceCached(nextUrl, nextSource.handledDatasets))))
                .then((newSources) => {
                if (newSources.length === 0 && this.sourceStates.length === 0) {
                    this.close();
                }
                else {
                    for (const sourceState of newSources) {
                        this.sourceStates.push(sourceState);
                    }
                    this.startIterator(this.sourceStates[0], false);
                    this.sourceStates.splice(0, 1);
                }
                done();
            }).catch((e) => this.emit('error', e));
        }
        else {
            done();
        }
    }
    getNextSourceCached(url, handledDatasets) {
        let source = this.sourcesState.sources.get(url);
        if (source) {
            return source;
        }
        source = this.getNextSource(url, handledDatasets);
        this.sourcesState.sources.set(url, source);
        return source;
    }
    /**
     * Start a new iterator for the given source.
     * Once the iterator is done, it will either determine a new source, or it will close the iterator.
     * @param {ISourceState} startSource The start source state.
     * @param {boolean} emitMetadata If the metadata event should be emitted.
     */
    startIterator(startSource, emitMetadata) {
        // Asynchronously execute the quad pattern query
        this.iterating = true;
        const it = startSource.source.match(this.subject, this.predicate, this.object, this.graph);
        let currentMetadata = startSource.metadata;
        let ended = false;
        // If the response emits metadata, override our metadata
        // For example, this will always be called for QPF sources (if not, then something is going wrong)
        it.on('metadata', (metadata) => {
            if (ended) {
                this.destroy(new Error('Received metadata AFTER the source iterator was ended.'));
            }
            currentMetadata = metadata;
        });
        it.on('data', (quad) => {
            this._push(quad);
            this.readable = true;
        });
        it.on('error', (e) => this.destroy(e));
        it.on('end', () => {
            ended = true;
            if (emitMetadata) {
                // Emit the metadata after all data has been processed.
                this.emit('metadata', currentMetadata);
            }
            // Store the metadata for next ._read call
            this.nextSource = {
                handledDatasets: Object.assign({}, startSource.handledDatasets),
                metadata: currentMetadata,
                source: null,
            };
            this.iterating = false;
            this.readable = true;
        });
    }
}
exports.LinkedRdfSourcesAsyncRdfIterator = LinkedRdfSourcesAsyncRdfIterator;
//# sourceMappingURL=LinkedRdfSourcesAsyncRdfIterator.js.map