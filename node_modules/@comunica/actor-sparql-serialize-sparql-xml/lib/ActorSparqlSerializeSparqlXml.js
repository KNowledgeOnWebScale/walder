"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const bus_sparql_serialize_1 = require("@comunica/bus-sparql-serialize");
const stream_1 = require("stream");
const xml = require("xml");
/**
 * A comunica sparql-results+xml Serialize Actor.
 */
class ActorSparqlSerializeSparqlXml extends bus_sparql_serialize_1.ActorSparqlSerializeFixedMediaTypes {
    constructor(args) {
        super(args);
    }
    /**
     * Converts an RDF term to its object-based XML representation.
     * @param {RDF.Term} value An RDF term.
     * @param {string} key A variable name, '?' must be included as a prefix.
     * @return {any} An object-based XML tag.
     */
    static bindingToXmlBindings(value, key) {
        let xmlValue;
        if (value.termType === 'Literal') {
            const literal = value;
            xmlValue = { literal: literal.value };
            const language = literal.language;
            const datatype = literal.datatype;
            if (language) {
                xmlValue.literal = [{ _attr: { 'xml:lang': language } }, xmlValue.literal];
            }
            else if (datatype && datatype.value !== 'http://www.w3.org/2001/XMLSchema#string') {
                xmlValue.literal = [{ _attr: { datatype: datatype.value } }, xmlValue.literal];
            }
        }
        else if (value.termType === 'BlankNode') {
            xmlValue = { bnode: value.value };
        }
        else {
            xmlValue = { uri: value.value };
        }
        return { binding: [{ _attr: { name: key.substring(1) } }, xmlValue] };
    }
    async testHandleChecked(action, context) {
        if (['bindings', 'boolean'].indexOf(action.type) < 0) {
            throw new Error('This actor can only handle bindings streams or booleans.');
        }
        return true;
    }
    async runHandle(action, mediaType, context) {
        const data = new stream_1.Readable();
        data._read = () => {
            return;
        };
        // Write head
        const root = xml.element({ _attr: { xlmns: 'http://www.w3.org/2005/sparql-results#' } });
        xml({ sparql: root }, { stream: true, indent: '  ', declaration: true })
            .on('data', (chunk) => data.push(chunk + '\n'));
        if (action.type === 'bindings' && action.variables.length) {
            root.push({ head: action.variables
                    .map((v) => ({ variable: { _attr: { name: v.substr(1) } } })) });
        }
        if (action.type === 'bindings') {
            const results = xml.element({});
            root.push({ results });
            const resultStream = action.bindingsStream;
            // Write bindings
            resultStream.on('error', (e) => {
                data.emit('error', e);
            });
            resultStream.on('data', (bindings) => {
                // XML SPARQL results spec does not allow unbound variables and blank node bindings
                const realBindings = bindings.filter((v, k) => !!v && k.startsWith('?'));
                results.push({ result: realBindings.map(ActorSparqlSerializeSparqlXml.bindingToXmlBindings) });
            });
            // Close streams
            resultStream.on('end', () => {
                results.close();
                root.close();
                data.push(null);
            });
        }
        else {
            try {
                root.push({ boolean: await action.booleanResult });
                root.close();
                setImmediate(() => data.push(null));
            }
            catch (e) {
                setImmediate(() => data.emit('error', e));
            }
        }
        return { data };
    }
}
exports.ActorSparqlSerializeSparqlXml = ActorSparqlSerializeSparqlXml;
//# sourceMappingURL=ActorSparqlSerializeSparqlXml.js.map