"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const bus_query_operation_1 = require("@comunica/bus-query-operation");
const asynciterator_promiseproxy_1 = require("asynciterator-promiseproxy");
const rdf_string_1 = require("rdf-string");
const rdf_terms_1 = require("rdf-terms");
/**
 * A comunica actor for handling 'quadpattern' query operations.
 */
class ActorQueryOperationQuadpattern extends bus_query_operation_1.ActorQueryOperationTyped {
    constructor(args) {
        super(args, 'pattern');
    }
    /**
     * Check if a term is a variable.
     * @param {RDF.Term} term An RDF term.
     * @return {any} If the term is a variable or blank node.
     */
    static isTermVariable(term) {
        return term.termType === 'Variable';
    }
    /**
     * Get all variables in the given pattern.
     * No duplicates are returned.
     * @param {RDF.BaseQuad} pattern A quad pattern.
     * @return {string[]} The variables in this pattern, without '?' prefix.
     */
    getVariables(pattern) {
        return rdf_terms_1.uniqTerms(rdf_terms_1.getTerms(pattern)
            .filter(ActorQueryOperationQuadpattern.isTermVariable))
            .map(rdf_string_1.termToString);
    }
    async testOperation(operation, context) {
        return true;
    }
    async runOperation(pattern, context) {
        // Resolve the quad pattern
        const result = await this.mediatorResolveQuadPattern.mediate({ pattern, context });
        // Collect all variables from the pattern
        const variables = this.getVariables(pattern);
        // Convenience datastructure for mapping quad elements to variables
        const elementVariables = rdf_terms_1.reduceTerms(pattern, (acc, term, key) => {
            if (ActorQueryOperationQuadpattern.isTermVariable(term)) {
                acc[key] = rdf_string_1.termToString(term);
            }
            return acc;
        }, {});
        const quadBindingsReducer = (acc, term, key) => {
            const variable = elementVariables[key];
            if (variable) {
                acc[variable] = term;
            }
            return acc;
        };
        const bindingsStream = new asynciterator_promiseproxy_1.PromiseProxyIterator(async () => result.data.map((quad) => {
            return bus_query_operation_1.Bindings(rdf_terms_1.reduceTerms(quad, quadBindingsReducer, {}));
        }, { autoStart: true, maxBufferSize: 128 }));
        return { type: 'bindings', bindingsStream, variables, metadata: result.metadata };
    }
}
exports.ActorQueryOperationQuadpattern = ActorQueryOperationQuadpattern;
//# sourceMappingURL=ActorQueryOperationQuadpattern.js.map