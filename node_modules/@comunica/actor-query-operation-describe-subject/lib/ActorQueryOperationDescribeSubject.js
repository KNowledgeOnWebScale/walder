"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const actor_query_operation_union_1 = require("@comunica/actor-query-operation-union");
const bus_query_operation_1 = require("@comunica/bus-query-operation");
const data_model_1 = require("@rdfjs/data-model");
const asynciterator_union_1 = require("asynciterator-union");
/**
 * A comunica Describe Subject Query Operation Actor.
 */
class ActorQueryOperationDescribeSubject extends bus_query_operation_1.ActorQueryOperationTypedMediated {
    constructor(args) {
        super(args, 'describe');
    }
    async testOperation(pattern, context) {
        return true;
    }
    async runOperation(pattern, context) {
        // Create separate construct queries for all non-variable terms
        const operations = pattern.terms
            .filter((term) => term.termType !== 'Variable')
            .map((term) => {
            // Transform each term to a separate construct operation with S ?p ?o patterns (BGP) for all terms
            const patterns = [
                data_model_1.triple(term, data_model_1.variable('__predicate'), data_model_1.variable('__object')),
            ];
            patterns.forEach((templatePattern) => templatePattern.type = 'pattern');
            const templateOperation = { type: 'bgp', patterns: patterns };
            // Create a construct query
            return {
                input: templateOperation,
                template: patterns,
                type: 'construct',
            };
        });
        // If we have variables in the term list,
        // create one separate construct operation to determine these variables using the input pattern.
        if (operations.length !== pattern.terms.length) {
            let variablePatterns = [];
            pattern.terms
                .filter((term) => term.termType === 'Variable')
                .forEach((term, i) => {
                // Transform each term to an S ?p ?o pattern in a non-conflicting way
                const patterns = [
                    data_model_1.triple(term, data_model_1.variable('__predicate' + i), data_model_1.variable('__object' + i)),
                ];
                patterns.forEach((templatePattern) => templatePattern.type = 'pattern');
                variablePatterns = variablePatterns.concat(patterns);
            });
            // Add a single construct for the variables
            // This requires a join between the input pattern and our variable patterns that form a simple BGP
            operations.push({
                input: { type: 'join', left: pattern.input, right: { type: 'bgp', patterns: variablePatterns } },
                template: variablePatterns,
                type: 'construct',
            });
        }
        // Evaluate the construct queries
        const outputs = (await Promise.all(operations.map((operation) => this.mediatorQueryOperation.mediate({ operation, context }))))
            .map(bus_query_operation_1.ActorQueryOperation.getSafeQuads);
        // Take the union of all quad streams
        const quadStream = new asynciterator_union_1.RoundRobinUnionIterator(outputs.map((output) => output.quadStream));
        // Take union of metadata
        const metadata = () => Promise.all(outputs
            .map((output) => output.metadata)
            .filter((m) => !!m)
            .map((m) => m()))
            .then(actor_query_operation_union_1.ActorQueryOperationUnion.unionMetadata);
        return { type: 'quads', quadStream, metadata };
    }
}
exports.ActorQueryOperationDescribeSubject = ActorQueryOperationDescribeSubject;
//# sourceMappingURL=ActorQueryOperationDescribeSubject.js.map