"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const jsonld_context_parser_1 = require("jsonld-context-parser");
/**
 * Utility functions and methods.
 */
class Util {
    /**
     * Convert an RDF term to a JSON value.
     * @param {Term} term An RDF term.
     * @param {IJsonLdContextNormalized} context The context.
     * @param {ITermToValueOptions} options Conversion options.
     * @return {any} A JSON value.
     */
    static termToValue(term, context, options = {
        compactIds: false,
        useNativeTypes: false,
    }) {
        switch (term.termType) {
            case 'NamedNode':
                const compacted = jsonld_context_parser_1.ContextParser.compactIri(term.value, context, options.vocab);
                return options.compactIds ? compacted : { '@id': compacted };
            case 'DefaultGraph':
                return options.compactIds ? term.value : { '@id': term.value };
            case 'BlankNode':
                const id = `_:${term.value}`;
                return options.compactIds ? id : { '@id': id };
            case 'Literal':
                const stringType = term.datatype.value === Util.XSD_STRING;
                const rawValue = {
                    '@value': !stringType && options.useNativeTypes
                        ? Util.stringToNativeType(term.value, term.datatype.value) : term.value,
                };
                if (term.language) {
                    return Object.assign({}, rawValue, { '@language': term.language });
                }
                else if (!stringType && typeof rawValue['@value'] === 'string') {
                    return Object.assign({}, rawValue, { '@type': term.datatype.value });
                }
                else {
                    return rawValue;
                }
        }
    }
    /**
     * Convert a string term to a native type.
     * If no conversion is possible, the original string will be returned.
     * @param {string} value An RDF term's string value.
     * @param {string} type
     * @return {any}
     */
    static stringToNativeType(value, type) {
        if (type.startsWith(Util.XSD)) {
            const xsdType = type.substr(Util.XSD.length);
            switch (xsdType) {
                case 'boolean':
                    if (value === 'true') {
                        return true;
                    }
                    else if (value === 'false') {
                        return false;
                    }
                    throw new Error(`Invalid xsd:boolean value '${value}'`);
                case 'integer':
                case 'number':
                case 'int':
                case 'byte':
                case 'long':
                    const parsedInt = parseInt(value, 10);
                    if (isNaN(parsedInt)) {
                        throw new Error(`Invalid xsd:integer value '${value}'`);
                    }
                    return parsedInt;
                case 'float':
                case 'decimal':
                case 'double':
                    const parsedFloat = parseFloat(value);
                    if (isNaN(parsedFloat)) {
                        throw new Error(`Invalid xsd:float value '${value}'`);
                    }
                    return parsedFloat;
            }
        }
        return value;
    }
}
Util.XSD = 'http://www.w3.org/2001/XMLSchema#';
Util.XSD_STRING = Util.XSD + 'string';
Util.RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';
Util.RDF_TYPE = Util.RDF + 'type';
exports.Util = Util;
//# sourceMappingURL=Util.js.map